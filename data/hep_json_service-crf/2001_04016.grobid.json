{
    "level": "sentence",
    "abstract": [
        {
            "text": "Inclusive Monte-Carlo samples are indispensable for signal selection and background suppression in many high energy physics experiments. ",
            "paragraph_rank": 1,
            "section_rank": 1
        },
        {
            "text": "A clear knowledge of the physics processes involved in the samples, including the types of processes and the number of processes in each type, is a great help to investigating signals and backgrounds. ",
            "paragraph_rank": 1,
            "section_rank": 1
        },
        {
            "text": "To help analysts obtain the physics process information from the truth information of the samples, we develop a physics process analysis program, TopoAna, with C++, ROOT, and LaTeX. ",
            "paragraph_rank": 1,
            "section_rank": 1
        },
        {
            "text": "The program implements the functionalities of component analysis and signal identification with many kinds of fine, customizable classification and matching algorithms. ",
            "paragraph_rank": 1,
            "section_rank": 1
        },
        {
            "text": "It tags physics processes in individual events accurately in the output root files, and exports the physics process information at the sample level clearly to the output plain text, tex source, and pdf files. ",
            "paragraph_rank": 1,
            "section_rank": 1
        },
        {
            "text": "Independent of specific software frameworks, the program is applicable to many experiments. ",
            "paragraph_rank": 1,
            "section_rank": 1
        },
        {
            "text": "At present, it has come into use in three e + e \u2212 colliding experiments: the BESIII, Belle, and Belle II experiments. ",
            "paragraph_rank": 1,
            "section_rank": 1
        },
        {
            "text": "The use of the program in other similar experiments is also prospective.",
            "paragraph_rank": 1,
            "section_rank": 1
        }
    ],
    "body_text": [
        {
            "text": "PROGRAM SUMMARY",
            "section_rank": 2
        },
        {
            "text": "Program title: TopoAna Licensing provisions: MIT Programming language: C++ Operating system: Linux Nature of problem: A clear knowledge of the physics processes involved in inclusive Monte-Carlo samples is a great help to investigating signals and backgrounds in many high energy physics experiments. ",
            "section": "PROGRAM SUMMARY",
            "paragraph_rank": 2,
            "section_rank": 2,
            "entity_spans": [
                {
                    "start": 93,
                    "end": 99,
                    "type": "software",
                    "rawForm": "Linux",
                    "resp": "service",
                    "id": "software-simple-s1"
                }
            ]
        },
        {
            "text": "However, the raw topology truth information of the samples is counter-intuitive, diverse, and overwhelming, which makes it difficult for analysts to check the physics process information of the samples directly. ",
            "section": "PROGRAM SUMMARY",
            "paragraph_rank": 2,
            "section_rank": 2
        },
        {
            "text": "Solution method: Based on accurate pattern matching, many kinds of fine, customizable classification and",
            "section": "PROGRAM SUMMARY",
            "paragraph_rank": 2,
            "section_rank": 2
        },
        {
            "text": "Introduction",
            "section_rank": 3
        },
        {
            "text": "One of the most important tasks in the data analysis of high energy physics experiments is to select signals, or in other words, to suppress backgrounds. ",
            "section": "Introduction",
            "paragraph_rank": 3,
            "section_rank": 3
        },
        {
            "text": "As for the task, inclusive/generic Monte-Carlo (MC) samples are extremely useful, in that they provide basic, though not perfect, descriptions of the signals and/or backgrounds involved. ",
            "section": "Introduction",
            "paragraph_rank": 3,
            "section_rank": 3
        },
        {
            "text": "However, due to the similarities between signals and some backgrounds, it usually takes efforts to establish a set of selection criteria that retain a high signal efficiency and meanwhile keep a low background level. ",
            "section": "Introduction",
            "paragraph_rank": 3,
            "section_rank": 3
        },
        {
            "text": "Further optimization of preliminary criteria is often needed in the process. ",
            "section": "Introduction",
            "paragraph_rank": 3,
            "section_rank": 3
        },
        {
            "text": "Under the circumstances, a comprehensive understanding of the samples is required. ",
            "section": "Introduction",
            "paragraph_rank": 3,
            "section_rank": 3
        },
        {
            "text": "In particular, a clear knowledge of the physics processes, or event types, involved in the samples is quite helpful. ",
            "section": "Introduction",
            "paragraph_rank": 3,
            "section_rank": 3
        },
        {
            "text": "To be specific, the physics process information includes the types of processes and the number of processes in each type, involved both in the entire samples and in the individual events. ",
            "section": "Introduction",
            "paragraph_rank": 3,
            "section_rank": 3
        },
        {
            "text": "Here, the physics process could be a complete production and decay process involved in an event, or merely a part of it, such as the decay of an intermediate resonance. ",
            "section": "Introduction",
            "paragraph_rank": 3,
            "section_rank": 3
        },
        {
            "text": "With the information, one can figure out the main backgrounds (especially the peaking ones), and optimize the selection criteria further by analyzing the differences between the main backgrounds and the signals. ",
            "section": "Introduction",
            "paragraph_rank": 3,
            "section_rank": 3
        },
        {
            "text": "Even if it is difficult to further suppress these backgrounds, the knowledge of their types is beneficial to estimate the systematic uncertainties associated with them.",
            "section": "Introduction",
            "paragraph_rank": 3,
            "section_rank": 3
        },
        {
            "text": "The analysis of the physics process information described above is a sort of component analysis. ",
            "section": "Introduction",
            "paragraph_rank": 4,
            "section_rank": 3
        },
        {
            "text": "It is complex since it has to classify physics processes actively and finely. ",
            "section": "Introduction",
            "paragraph_rank": 4,
            "section_rank": 3
        },
        {
            "text": "Another sort of physics process analysis often required in practice is signal identification, which only aims to search for certain processes of interests. ",
            "section": "Introduction",
            "paragraph_rank": 4,
            "section_rank": 3
        },
        {
            "text": "It is relatively simple because its core technique is merely pattern matching. ",
            "section": "Introduction",
            "paragraph_rank": 4,
            "section_rank": 3
        },
        {
            "text": "Mostly, signal and background events coexist in inclusive MC samples. ",
            "section": "Introduction",
            "paragraph_rank": 4,
            "section_rank": 3
        },
        {
            "text": "It is useful to differentiate them in such cases. ",
            "section": "Introduction",
            "paragraph_rank": 4,
            "section_rank": 3
        },
        {
            "text": "The identified signal events can be used to make up a signal sample in the absence of specialized signal samples, or they can be removed to avoid repetition in the presence of specialized signal samples. ",
            "section": "Introduction",
            "paragraph_rank": 4,
            "section_rank": 3
        },
        {
            "text": "Occasionally, we have to pick out some decay branches in order to re-weight them according to new theoretical predictions or updated experimental measurements. ",
            "section": "Introduction",
            "paragraph_rank": 4,
            "section_rank": 3
        },
        {
            "text": "Signal identification also plays a part in this occasion.",
            "section": "Introduction",
            "paragraph_rank": 4,
            "section_rank": 3
        },
        {
            "text": "Processes in high energy physics can be visualized with topology diagrams. ",
            "section": "Introduction",
            "paragraph_rank": 5,
            "section_rank": 3
        },
        {
            "text": "As an example, Fig. 1 shows the topology diagrams of two typical physics processes occurring at e + e \u2212 colliders. ",
            "section": "Introduction",
            "paragraph_rank": 5,
            "section_rank": 3,
            "ref_spans": [
                {
                    "start": 15,
                    "end": 21,
                    "type": "figure",
                    "text": "Fig. 1"
                }
            ]
        },
        {
            "text": "From the figure, the hierarchies of the processes and the relationships among the particles are clearly illustrated with the diagrams. ",
            "section": "Introduction",
            "paragraph_rank": 5,
            "section_rank": 3
        },
        {
            "text": "Though the complexities of topology diagrams vary with physics processes, there is only one diagram corresponding to each process. ",
            "section": "Introduction",
            "paragraph_rank": 5,
            "section_rank": 3
        },
        {
            "text": "For this reason, we refer to the physics process information/analysis mentioned thereinbefore as topology information/analysis hereinafter. ",
            "section": "Introduction",
            "paragraph_rank": 5,
            "section_rank": 3
        },
        {
            "text": "The component analysis and signal identification introduced above are exactly the two categories of topology analysis that will be discussed in this paper.",
            "section": "Introduction",
            "paragraph_rank": 5,
            "section_rank": 3
        },
        {
            "text": "Since the raw topology truth information of inclusive MC samples is counter-intuitive, diverse, and overwhelming, it is difficult for analysts to check the topology information of the ",
            "section": "Introduction",
            "paragraph_rank": 6,
            "section_rank": 3
        },
        {
            "text": "Figure 1: Topology diagrams of ",
            "section": "Introduction",
            "paragraph_rank": 7,
            "section_rank": 3
        },
        {
            "text": "(a) e + e \u2212 \u2192 J/\u03c8, J/\u03c8 \u2192 \u03c1 + \u03c0 \u2212 , \u03c1 + \u2192 \u03c0 + \u03c0 0 , \u03c0 0 \u2192 \u03b3\u03b3 and ",
            "section": "Introduction",
            "paragraph_rank": 7,
            "section_rank": 3
        },
        {
            "text": "(b) e + e \u2212 \u2192 \u03a5(4S ), \u03a5(4S ) \u2192 B 0B0 , B 0 \u2192 K 0 S J/\u03c8,B 0 \u2192 \u00b5 \u2212 D * + \u03bd \u00b5 , K 0 S \u2192 \u03c0 + \u03c0 \u2212 , J/\u03c8 \u2192 e + e \u2212 , D * + \u2192 D 0 \u03c0 + , D 0 \u2192 \u03c0 0 \u03c0 + K \u2212 , \u03c0 0 \u2192 \u03b3\u03b3. ",
            "section": "Introduction",
            "paragraph_rank": 7,
            "section_rank": 3
        },
        {
            "text": "As if trees grow, the diagrams are plotted from bottom to top. ",
            "section": "Introduction",
            "paragraph_rank": 7,
            "section_rank": 3
        },
        {
            "text": "samples directly. ",
            "section": "Introduction",
            "paragraph_rank": 7,
            "section_rank": 3
        },
        {
            "text": "To help them do the checks quickly and easily, a topology analysis program called TopoAna is developed with C++, ROOT [1], and LaTeX. ",
            "section": "Introduction",
            "paragraph_rank": 7,
            "section_rank": 3,
            "ref_spans": [
                {
                    "start": 118,
                    "end": 121,
                    "type": "bibr",
                    "ref_id": "b0",
                    "text": "[1]"
                }
            ],
            "entity_spans": [
                {
                    "start": 82,
                    "end": 90,
                    "type": "software",
                    "rawForm": "TopoAna",
                    "resp": "service",
                    "id": "software-simple-s2"
                },
                {
                    "start": 113,
                    "end": 118,
                    "type": "software",
                    "rawForm": "ROOT",
                    "resp": "service",
                    "id": "software-simple-s3"
                },
                {
                    "start": 127,
                    "end": 132,
                    "type": "software",
                    "rawForm": "LaTeX",
                    "resp": "service",
                    "id": "software-simple-s4"
                }
            ]
        },
        {
            "text": "Here, C++ is the programming language, ROOT is the C++ based data analysis software universally used in modern high energy physics experiments, and LaTeX is used for generating pdf documents containing the obtained topology information. ",
            "section": "Introduction",
            "paragraph_rank": 7,
            "section_rank": 3,
            "entity_spans": [
                {
                    "start": 39,
                    "end": 43,
                    "type": "software",
                    "rawForm": "ROOT",
                    "resp": "service",
                    "id": "software-simple-s5"
                },
                {
                    "start": 148,
                    "end": 154,
                    "type": "software",
                    "rawForm": "LaTeX",
                    "resp": "service",
                    "id": "software-simple-s6"
                }
            ]
        },
        {
            "text": "The program implements the functionalities of component analysis and signal identification based on accurate pattern matching. ",
            "section": "Introduction",
            "paragraph_rank": 7,
            "section_rank": 3
        },
        {
            "text": "To meet a variety of practical requirements, many kinds of fine, customizable classification and matching algorithms are implemented in the program. ",
            "section": "Introduction",
            "paragraph_rank": 7,
            "section_rank": 3
        },
        {
            "text": "Generally, the program recognizes, categorizes, and counts physics processes in each event in the samples, and tags them in the corresponding entry of the output root (TFile [2]) files. ",
            "section": "Introduction",
            "paragraph_rank": 7,
            "section_rank": 3
        },
        {
            "text": "After processing the events, the program exports the obtained topology information at the sample level to the output plain text, tex source, and pdf files.",
            "section": "Introduction",
            "paragraph_rank": 7,
            "section_rank": 3
        },
        {
            "text": "The program is applicable to inclusive MC samples at any data analysis stage of associated high energy physics experiments. ",
            "section": "Introduction",
            "paragraph_rank": 8,
            "section_rank": 3
        },
        {
            "text": "In the overwhelming majority of situations, it is run over the samples which have undergone some selections, in order to examine the signals and backgrounds in the selected samples as well as the effect of the imposed selections. ",
            "section": "Introduction",
            "paragraph_rank": 8,
            "section_rank": 3
        },
        {
            "text": "In such situations, the results of topology analysis are usually used together with other quantities for physics analysis. ",
            "section": "Introduction",
            "paragraph_rank": 8,
            "section_rank": 3
        },
        {
            "text": "In spite of this, applying the program to the samples without undergoing any selection facilitates us to validate the generators and decay cards that produce the samples and helps novices get familiar with the topology information of the samples.",
            "section": "Introduction",
            "paragraph_rank": 8,
            "section_rank": 3
        },
        {
            "text": "The program has a history of more than ten years. ",
            "section": "Introduction",
            "paragraph_rank": 9,
            "section_rank": 3
        },
        {
            "text": "It has already gone through a series of major upgrades. ",
            "section": "Introduction",
            "paragraph_rank": 9,
            "section_rank": 3
        },
        {
            "text": "Prior to its development, analysts usually wrote some private codes to match few signals and/or backgrounds for their own studies. ",
            "section": "Introduction",
            "paragraph_rank": 9,
            "section_rank": 3
        },
        {
            "text": "The limited functions of these codes do not satisfy the increasing demand for topology analysis. ",
            "section": "Introduction",
            "paragraph_rank": 9,
            "section_rank": 3
        },
        {
            "text": "This motivates us to develop a generic, powerful, and easy-to-use program. ",
            "section": "Introduction",
            "paragraph_rank": 9,
            "section_rank": 3
        },
        {
            "text": "At first, the program was developed for the BESIII experiment, an experiment in the \u03c4-Charm energy region with abundant research topics under study [3,4]. ",
            "section": "Introduction",
            "paragraph_rank": 9,
            "section_rank": 3,
            "ref_spans": [
                {
                    "start": 148,
                    "end": 151,
                    "type": "bibr",
                    "ref_id": "b1",
                    "text": "[3,"
                },
                {
                    "start": 151,
                    "end": 153,
                    "type": "bibr",
                    "ref_id": "b2",
                    "text": "4]"
                }
            ]
        },
        {
            "text": "Later, it was extended substantially for the Belle II experiment, which is primarily dedicated to search for physics beyond the Standard Model in the flavor sector and has already started data taking in the recent three years [5]. ",
            "section": "Introduction",
            "paragraph_rank": 9,
            "section_rank": 3,
            "ref_spans": [
                {
                    "start": 226,
                    "end": 229,
                    "type": "bibr",
                    "ref_id": "b3",
                    "text": "[5]"
                }
            ]
        },
        {
            "text": "Besides, the program has also been tried and used in the Belle experiment, the predecessor of the Belle II experiment, where some physics studies are still ongoing [6]. ",
            "section": "Introduction",
            "paragraph_rank": 9,
            "section_rank": 3,
            "ref_spans": [
                {
                    "start": 164,
                    "end": 167,
                    "type": "bibr",
                    "ref_id": "b4",
                    "text": "[6]"
                }
            ]
        },
        {
            "text": "Not relying on any specific software frameworks, the program now applies to many high energy physics experiments.",
            "section": "Introduction",
            "paragraph_rank": 9,
            "section_rank": 3
        },
        {
            "text": "This paper gives an essential description of TopoAna. ",
            "section": "Introduction",
            "paragraph_rank": 10,
            "section_rank": 3
        },
        {
            "text": "It proceeds as follows: Section 2 introduces the basics of the program; Sections 3 and 4 expatiate the two categories of functionalities of the program -component analysis and signal identification, respectively; Section 5 presents some common settings for the executing of the program; Section 6 summarizes the paper. ",
            "section": "Introduction",
            "paragraph_rank": 10,
            "section_rank": 3
        },
        {
            "text": "It is worth mentioning here that, aside from the essential description in the paper, a detailed description of the program can be found in the file \"user guide v*.pdf\" under the directory \"share\" of the package.",
            "section": "Introduction",
            "paragraph_rank": 10,
            "section_rank": 3
        },
        {
            "text": "Basics of the program",
            "section_rank": 4
        },
        {
            "text": "This section introduces the basics of the program, including the package, input, algorithm, execution, performance, output, and validation of the program. ",
            "section": "Basics of the program",
            "paragraph_rank": 11,
            "section_rank": 4
        },
        {
            "text": "The package implements the program via a C++ class called \"topoana\" and a main function invoking the class. ",
            "section": "Basics of the program",
            "paragraph_rank": 11,
            "section_rank": 4
        },
        {
            "text": "Compiling the package creates the executable file of the program, that is, \"topoana.exe\". ",
            "section": "Basics of the program",
            "paragraph_rank": 11,
            "section_rank": 4
        },
        {
            "text": "To execute the program, we have to first obtain the input data of the program, namely the raw topology truth information of the inclusive MC samples, with some interfaces to the program in the software systems of the corresponding experiments. ",
            "section": "Basics of the program",
            "paragraph_rank": 11,
            "section_rank": 4
        },
        {
            "text": "Normally, the input data contain all the topology information of the samples. ",
            "section": "Basics of the program",
            "paragraph_rank": 11,
            "section_rank": 4
        },
        {
            "text": "With the data, all kinds of the topology analysis presented in the paper can be performed.",
            "section": "Basics of the program",
            "paragraph_rank": 11,
            "section_rank": 4
        },
        {
            "text": "To carry out the topology analysis desired in our work, we have to provide some necessary input, functionality, and output information to the program. ",
            "section": "Basics of the program",
            "paragraph_rank": 12,
            "section_rank": 4
        },
        {
            "text": "The information is required to be filled in the setting items designed and implemented in the program, and the items have to be put in a plain text file named with a suffix \".card\". ",
            "section": "Basics of the program",
            "paragraph_rank": 12,
            "section_rank": 4
        },
        {
            "text": "With the card file, one can execute the program with the command line: \"topoana.exe cardFileName\", where the argument \"cardFile-Name\" is optional and its default value is \"topoana.card\". ",
            "section": "Basics of the program",
            "paragraph_rank": 12,
            "section_rank": 4,
            "entity_spans": [
                {
                    "start": 119,
                    "end": 132,
                    "type": "software",
                    "rawForm": "cardFile-Name",
                    "resp": "service",
                    "id": "software-simple-s7"
                }
            ]
        },
        {
            "text": "After the execution of the program, we can examine the results of topology analysis in the output files and use them to analyze other experimental quantities. ",
            "section": "Basics of the program",
            "paragraph_rank": 12,
            "section_rank": 4
        },
        {
            "text": "The results help us gain a better understanding of the signals and backgrounds and are conducive to carrying our work forward. ",
            "section": "Basics of the program",
            "paragraph_rank": 12,
            "section_rank": 4
        },
        {
            "text": "Besides the package, input, execution, and output of the program mentioned above, the algorithm, performance, and validation of the program will also be discussed in this section, because they are also essential aspects of the program. ",
            "section": "Basics of the program",
            "paragraph_rank": 12,
            "section_rank": 4
        },
        {
            "text": "In the next seven subsections, we will present the package, input, algorithm, execution, performance, output, and validation of the program in detail, with each part in one subsection.",
            "section": "Basics of the program",
            "paragraph_rank": 12,
            "section_rank": 4
        },
        {
            "text": "Package of the program",
            "section_rank": 5
        },
        {
            "text": "The package consists of six directories -\"include\", \"src\", \"bin\", \"share\", \"examples\", and \"utilities\" -and five files -\"LICENSE\", \"README.md\", \"Configure\", \"Makefile\", and \"Setup\". ",
            "section": "Package of the program",
            "paragraph_rank": 13,
            "section_rank": 5,
            "entity_spans": [
                {
                    "start": 132,
                    "end": 138,
                    "type": "software",
                    "rawForm": "README",
                    "resp": "service",
                    "id": "software-simple-s8"
                }
            ]
        },
        {
            "text": "While the directory \"include\" only includes one header file \"topoana.h\", the directory \"src\" contains sixty source files \"*.cpp\" as well as a script file \"topoana.C\". ",
            "section": "Package of the program",
            "paragraph_rank": 13,
            "section_rank": 5
        },
        {
            "text": "At present, only one class, namely \"topoana\", is defined in the program for all of its functionalities. ",
            "section": "Package of the program",
            "paragraph_rank": 13,
            "section_rank": 5
        },
        {
            "text": "The class is declared in \"topoana.h\", implemented in \"*.cpp\" files, and invoked in \"topoana.C\".",
            "section": "Package of the program",
            "paragraph_rank": 13,
            "section_rank": 5
        },
        {
            "text": "The file \"template topoana.card\" under the directory \"share\" saves all the items which are developed for users to specify information for the execution of the program. ",
            "section": "Package of the program",
            "paragraph_rank": 14,
            "section_rank": 5
        },
        {
            "text": "One can refer to the file when filling in the cards for their own needs. ",
            "section": "Package of the program",
            "paragraph_rank": 14,
            "section_rank": 5
        },
        {
            "text": "Some plain text files \"pid 3pchrg txtpnm texpnm iccp.dat *\" are also included in the directory \"share\". ",
            "section": "Package of the program",
            "paragraph_rank": 14,
            "section_rank": 5
        },
        {
            "text": "They store the basic information of the particles used in the program. ",
            "section": "Package of the program",
            "paragraph_rank": 14,
            "section_rank": 5
        },
        {
            "text": "The suffixes of their names indicate the experiments they apply to. ",
            "section": "Package of the program",
            "paragraph_rank": 14,
            "section_rank": 5
        },
        {
            "text": "One of them will be copied to \"pid 3pchrg txtpnm texpnm iccp.dat\" when we set up the program. ",
            "section": "Package of the program",
            "paragraph_rank": 14,
            "section_rank": 5
        },
        {
            "text": "Besides, the directory \"share\" also contains three LaTeX style files \" geometry.sty\", \"ifxetex.sty\", and \"makecell.sty\", which are invoked by the program for generating pdf files. ",
            "section": "Package of the program",
            "paragraph_rank": 14,
            "section_rank": 5,
            "entity_spans": [
                {
                    "start": 51,
                    "end": 57,
                    "type": "software",
                    "rawForm": "LaTeX",
                    "resp": "service",
                    "id": "software-simple-s9"
                }
            ]
        },
        {
            "text": "The directory \"examples\" includes plenty of detailed examples. ",
            "section": "Package of the program",
            "paragraph_rank": 14,
            "section_rank": 5
        },
        {
            "text": "Particularly, all the examples involved in this paper are under its sub-directory \"in the paper\". ",
            "section": "Package of the program",
            "paragraph_rank": 14,
            "section_rank": 5
        },
        {
            "text": "The directory \"utilities\" contains some useful bash scripts.",
            "section": "Package of the program",
            "paragraph_rank": 14,
            "section_rank": 5
        },
        {
            "text": "The program is released under MIT license [7]. ",
            "section": "Package of the program",
            "paragraph_rank": 15,
            "section_rank": 5,
            "ref_spans": [
                {
                    "start": 42,
                    "end": 45,
                    "type": "bibr",
                    "ref_id": "b5",
                    "text": "[7]"
                }
            ]
        },
        {
            "text": "The file \"README.md\" briefly introduces how to install and use the program. ",
            "section": "Package of the program",
            "paragraph_rank": 15,
            "section_rank": 5,
            "entity_spans": [
                {
                    "start": 10,
                    "end": 16,
                    "type": "software",
                    "rawForm": "README",
                    "resp": "service",
                    "id": "software-simple-s10"
                }
            ]
        },
        {
            "text": "To set up the program, one should first set the package path with the command \"./Configure\". ",
            "section": "Package of the program",
            "paragraph_rank": 15,
            "section_rank": 5
        },
        {
            "text": "Standard outputs of the command are the guidelines for manually adding the absolute path of \"topoana.exe\" to the environment variable \"PATH\", in order to execute it without any path. ",
            "section": "Package of the program",
            "paragraph_rank": 15,
            "section_rank": 5
        },
        {
            "text": "The second step is executing the command \"make\". ",
            "section": "Package of the program",
            "paragraph_rank": 15,
            "section_rank": 5
        },
        {
            "text": "This command compiles the header, source, and script files into the executable file \"topoana.exe\" under the directory \"bin\", according to the rules specified in the \"Makefile\". ",
            "section": "Package of the program",
            "paragraph_rank": 15,
            "section_rank": 5
        },
        {
            "text": "The last step is specifying the experiment name with the command line \"./Setup experimentName\". ",
            "section": "Package of the program",
            "paragraph_rank": 15,
            "section_rank": 5
        },
        {
            "text": "Currently, the supported experiment names are \"BESIII\", \"Belle\", and \"Belle II\". ",
            "section": "Package of the program",
            "paragraph_rank": 15,
            "section_rank": 5
        },
        {
            "text": "Besides, \"./Setup Example\" is required for the execution of the examples in the paper.",
            "section": "Package of the program",
            "paragraph_rank": 15,
            "section_rank": 5
        },
        {
            "text": "Input of the program",
            "section_rank": 6
        },
        {
            "text": "The input of the program is one or more root files including a TTree [2] object which has some TBranch [2] objects containing the raw topology truth information of the inclusive MC samples under study. ",
            "section": "Input of the program",
            "paragraph_rank": 16,
            "section_rank": 6
        },
        {
            "text": "To be specific, the information in each entry of the TTree object consists of the following three ingredients associated with the particles produced in an event of the samples: the number of particles, PDG [8] codes of particles, and mother indices of particles. ",
            "section": "Input of the program",
            "paragraph_rank": 16,
            "section_rank": 6,
            "ref_spans": [
                {
                    "start": 206,
                    "end": 209,
                    "type": "bibr",
                    "ref_id": "b6",
                    "text": "[8]"
                }
            ]
        },
        {
            "text": "Notably, the particles do not include the initial state particles (e + and e \u2212 in e + e \u2212 colliding experiments), which are default and thus omitted. ",
            "section": "Input of the program",
            "paragraph_rank": 16,
            "section_rank": 6
        },
        {
            "text": "Besides, the indices of particles are integers starting from zero (included) to the number of particles (excluded); they are obvious and hence not taken as an input ingredient for topology analysis. ",
            "section": "Input of the program",
            "paragraph_rank": 16,
            "section_rank": 6
        },
        {
            "text": "Equation (1) shows an example of the input data. ",
            "section": "Input of the program",
            "paragraph_rank": 16,
            "section_rank": 6,
            "ref_spans": [
                {
                    "start": 9,
                    "end": 12,
                    "type": "bibr",
                    "ref_id": "b0",
                    "text": "(1)"
                }
            ]
        },
        {
            "text": "The complete physics process contained in the data is displayed as follows.",
            "section": "Input of the program",
            "paragraph_rank": 17,
            "section_rank": 6
        },
        {
            "text": "0 e + e \u2212 \u2192 \u03a5(4S ) -1 9",
            "section": "Input of the program",
            "paragraph_rank": 18,
            "section_rank": 6
        },
        {
            "text": "Here, the decay branches in the process are placed into two blocks in order to make full use of the page space. ",
            "section": "Input of the program",
            "paragraph_rank": 19,
            "section_rank": 6
        },
        {
            "text": "In both blocks, the first, second, and third columns are the indices, symbolic expressions, and mother indices of the decay branches. ",
            "section": "Input of the program",
            "paragraph_rank": 19,
            "section_rank": 6
        },
        {
            "text": "Notably, all the decay branches of \u03c0 0 \u2192 \u03b3\u03b3 are omitted in Eq. ",
            "section": "Input of the program",
            "paragraph_rank": 19,
            "section_rank": 6
        },
        {
            "text": "(2) in order to make the process look more concise. ",
            "section": "Input of the program",
            "paragraph_rank": 19,
            "section_rank": 6
        },
        {
            "text": "Since the topology diagram of such a process looks like a tree, we refer to the complete processes as decay trees. ",
            "section": "Input of the program",
            "paragraph_rank": 19,
            "section_rank": 6
        },
        {
            "text": "Obviously, the input data do not show the structure automatically. ",
            "section": "Input of the program",
            "paragraph_rank": 19,
            "section_rank": 6
        },
        {
            "text": "Thus, we need the program to do the topology analysis work. ",
            "section": "Input of the program",
            "paragraph_rank": 19,
            "section_rank": 6
        },
        {
            "text": "From the first branch in Eq. ",
            "section": "Input of the program",
            "paragraph_rank": 19,
            "section_rank": 6
        },
        {
            "text": "(2), only one particle \u03a5(4S ) is produced after the e + e \u2212 annihilation. ",
            "section": "Input of the program",
            "paragraph_rank": 19,
            "section_rank": 6
        },
        {
            "text": "Thus, \u03a5(4S ) can be referred to as the root particle of the decay tree. ",
            "section": "Input of the program",
            "paragraph_rank": 19,
            "section_rank": 6
        },
        {
            "text": "Similarly, many other resonances with the quantum numbers J PC = 1 \u2212\u2212 , such as J/\u03c8, can be solely produced at other proper energy points. ",
            "section": "Input of the program",
            "paragraph_rank": 19,
            "section_rank": 6
        },
        {
            "text": "Besides the cases with only one root particle, the program can deal with the cases with multiple root particles. ",
            "section": "Input of the program",
            "paragraph_rank": 19,
            "section_rank": 6
        },
        {
            "text": "For example, the program can recognize the following raw topology truth information ",
            "section": "Input of the program",
            "paragraph_rank": 19,
            "section_rank": 6
        },
        {
            "text": "as the following process",
            "section": "Input of the program",
            "paragraph_rank": 20,
            "section_rank": 6
        },
        {
            "text": "Here, the particles \u03c0 + \u03c9K \u2212 D * \u2212 D * + s in the first branch arise from hadronization processes, in which quark pairs produced from initial state particles turn into hadrons. ",
            "section": "Input of the program",
            "paragraph_rank": 21,
            "section_rank": 6
        },
        {
            "text": "The processes with hadronization ignored have a tree structure and thus are easy to resolve. ",
            "section": "Input of the program",
            "paragraph_rank": 21,
            "section_rank": 6
        },
        {
            "text": "On the other hand, some hadronization processes, particularly those in high energy regions, contain complicated loop structures that are difficult to resolve without sophisticated algorithms. ",
            "section": "Input of the program",
            "paragraph_rank": 21,
            "section_rank": 6
        },
        {
            "text": "Resolving these intricate hadronization processes is not involved in the program at present.",
            "section": "Input of the program",
            "paragraph_rank": 21,
            "section_rank": 6
        },
        {
            "text": "The input data are recommended to be saved in the TTree object together with other quantities for physics analysis, in order to facilitate the examination of the distributions of these quantities with the topology information. ",
            "section": "Input of the program",
            "paragraph_rank": 22,
            "section_rank": 6
        },
        {
            "text": "It is easy to get the input of the program within the software framework of high energy physics experiments. ",
            "section": "Input of the program",
            "paragraph_rank": 22,
            "section_rank": 6
        },
        {
            "text": "To facilitate its use, we have developed the interfaces of the program to the software systems of the BESIII, Belle, and Belle II experiments. ",
            "section": "Input of the program",
            "paragraph_rank": 22,
            "section_rank": 6
        },
        {
            "text": "Similar interfaces for other experiments can also be implemented with ease. ",
            "section": "Input of the program",
            "paragraph_rank": 22,
            "section_rank": 6
        },
        {
            "text": "Beyond the scope of the paper, we will not discuss the details of the interfaces here.",
            "section": "Input of the program",
            "paragraph_rank": 22,
            "section_rank": 6
        },
        {
            "text": "Algorithm of the program",
            "section_rank": 7
        },
        {
            "text": "The program resolves physics processes from the input data introduced above. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 23,
            "section_rank": 7
        },
        {
            "text": "Considering the diversity of the data, the program first sorts them before translating them into physics processes. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 23,
            "section_rank": 7
        },
        {
            "text": "Here, the diversity means that the data representing a process may have multiple permutations. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 23,
            "section_rank": 7
        },
        {
            "text": "For example, the data for the decay \u03c1 0 \u2192 \u03c0 + \u03c0 \u2212 have the following two permutations. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 23,
            "section_rank": 7
        },
        {
            "text": "A decay tree can consist of many decay branches. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 23,
            "section_rank": 7
        },
        {
            "text": "As a consequence, the diversity issue is complex. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 23,
            "section_rank": 7
        },
        {
            "text": "To avoid the different permutations of one group of data are identified as different processes, the program first sorts the input data to adjust all the possible permutations to a unique order, according to the PDG codes and electronic charges of the involved particles, and the numbers of their daughter particles in the case of identical particles present in the same decay branch. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 23,
            "section_rank": 7
        },
        {
            "text": "For example, the two permutations above will be finally sorted into the first permutation (113, 211, \u2212211) in the program. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 23,
            "section_rank": 7
        },
        {
            "text": "The sorting algorithm is implemented in the source file \"sortPs.cpp\", where some other settings are also involved. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 23,
            "section_rank": 7
        },
        {
            "text": "One can see the reference file \"sortPs.cpp core\" for the core of the sorting algorithm. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 23,
            "section_rank": 7
        },
        {
            "text": "After the sorting, the program can get the decay tree from the sorted data into a vector of the type \"vector< list<int> >\" with the function implemented in the source file \"getDcyTr.cpp\".",
            "section": "Algorithm of the program",
            "paragraph_rank": 23,
            "section_rank": 7,
            "entity_spans": [
                {
                    "start": 173,
                    "end": 185,
                    "type": "software",
                    "rawForm": "getDcyTr.cpp",
                    "resp": "service",
                    "id": "software-simple-s11"
                }
            ]
        },
        {
            "text": "As mentioned in the previous section, the program has two categories of functionalities: signal identification and component analysis. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 24,
            "section_rank": 7
        },
        {
            "text": "In this subsection, we introduce the basic algorithms for signal identification and component analysis by taking the cases of decay trees as examples. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 24,
            "section_rank": 7
        },
        {
            "text": "Figures 2 and 3 show the flow charts of these algorithms in detail. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 24,
            "section_rank": 7,
            "ref_spans": [
                {
                    "start": 0,
                    "end": 15,
                    "type": "figure",
                    "ref_id": "fig_2",
                    "text": "Figures 2 and 3"
                }
            ]
        },
        {
            "text": "Dozens of lines of code, including some using the ROOT classes TChain, TFile, and TTree [2], are involved in the charts in order to express the algorithms explicitly. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 24,
            "section_rank": 7,
            "entity_spans": [
                {
                    "start": 50,
                    "end": 55,
                    "type": "software",
                    "rawForm": "ROOT",
                    "resp": "service",
                    "id": "software-simple-s12"
                },
                {
                    "start": 82,
                    "end": 88,
                    "type": "software",
                    "rawForm": "TTree",
                    "resp": "service",
                    "id": "software-simple-s13"
                }
            ]
        },
        {
            "text": "The flow chart of the signal identification for decay trees is depicted in Fig. 2. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 24,
            "section_rank": 7,
            "ref_spans": [
                {
                    "start": 75,
                    "end": 81,
                    "type": "figure",
                    "ref_id": "fig_2",
                    "text": "Fig. 2"
                }
            ]
        },
        {
            "text": "Firstly, the program reads in the signal decay trees specified in the user card file. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 24,
            "section_rank": 7
        },
        {
            "text": "Then, for each entry of the input root file, the program obtains the decay tree from the sorted input data, matches the decay tree to the signal decay trees, records the index of the matched signal decay tree, and increases the number of the matched signal decay tree. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 24,
            "section_rank": 7
        },
        {
            "text": "At last, the program outputs the statistics of the signal decay trees.",
            "section": "Algorithm of the program",
            "paragraph_rank": 24,
            "section_rank": 7
        },
        {
            "text": "The flow chart of the component analysis over decay trees is illustrated in Fig. 3. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 25,
            "section_rank": 7,
            "ref_spans": [
                {
                    "start": 76,
                    "end": 82,
                    "type": "figure",
                    "ref_id": "fig_3",
                    "text": "Fig. 3"
                }
            ]
        },
        {
            "text": "Despite the similarity in their frameworks, the flow chart has significant differences from that of the signal identification for decay trees in Fig. 2. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 25,
            "section_rank": 7,
            "ref_spans": [
                {
                    "start": 145,
                    "end": 151,
                    "type": "figure",
                    "ref_id": "fig_2",
                    "text": "Fig. 2"
                }
            ]
        },
        {
            "text": "In the signal identification algorithm, the signal decay trees to be identified are specified beforehand in the user card file. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 25,
            "section_rank": 7
        },
        {
            "text": "On the contrary, in the component analysis algorithm, the program has to classify decay trees by itself from scratch. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 25,
            "section_rank": 7
        },
        {
            "text": "In the signal identification algorithm, the decay trees are matched by directly comparing the vectors storing them. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 25,
            "section_rank": 7
        },
        {
            "text": "Since the number of specified signal decay trees is fixed and usually small, the processing rate of the program is high and usually in constant. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 25,
            "section_rank": 7
        },
        {
            "text": "However, in the component analysis algorithm, the number of decay tree types found in a sample can be quite large and tends to grow with the number of processed entries. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 25,
            "section_rank": 7
        },
        {
            "text": "On this occasion, if we still match the decay trees by comparing the vectors storing them, the processing rate of the program will decrease with the increase of the number of processed entries. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 25,
            "section_rank": 7
        },
        {
            "text": "To improve the processing rate, the unordered map [9], a kind of container template introduced since the C++ 11 standard, is employed for the fast matching of decay trees. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 25,
            "section_rank": 7
        },
        {
            "text": "Internally, the elements in the unordered maps are organized into buckets depending on their hash values, to allow for fast access to individual elements directly by their key values with a constant average time complexity [9]. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 25,
            "section_rank": 7
        },
        {
            "text": "This constant feature in average time complexity will be examined in Section 2.5. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 25,
            "section_rank": 7
        },
        {
            "text": ": Basic flow chart of the signal identification for decay trees. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 25,
            "section_rank": 7
        },
        {
            "text": "The vectors \"vSigDcyTr\" and \"vNSigDcyTr\" are used to store the signal decay trees specified in the user card file and the numbers of these decay trees found in the input root file, respectively. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 25,
            "section_rank": 7
        },
        {
            "text": "The TBranch \"iSigDcyTr\" in the output root file is used to record the index of the signal decay tree involved in each entry of the input root file. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 25,
            "section_rank": 7
        },
        {
            "text": "The TBranch \"iDcyTr\" in the output root file is used to record the index of the decay tree involved in each entry of the input root file. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 25,
            "section_rank": 7
        },
        {
            "text": "The vectors \"vDcyTr\", \"vIDcyTr\", and \"vNDcyTr\" are used to store the decay trees found in the input root file, their individual indices, and their individual numbers, respectively. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 25,
            "section_rank": 7
        },
        {
            "text": "In addition, the unordered map \"uomDcyTr\" is used for the fast matching of decay trees. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 25,
            "section_rank": 7
        },
        {
            "text": "Its key and value are the string \"strDcyTr\" and the index \"iDcyTr\", respectively. ",
            "section": "Algorithm of the program",
            "paragraph_rank": 25,
            "section_rank": 7
        },
        {
            "text": "Here, the string \"strDcyTr\" is constructed from the vector \"dcyTr\"; there is a one-to-one correspondence between them.",
            "section": "Algorithm of the program",
            "paragraph_rank": 25,
            "section_rank": 7
        },
        {
            "text": "Execution of the program",
            "section_rank": 8
        },
        {
            "text": "To execute the program, we have to first configure some necessary setting items in a card file, and then run the program with the command line: \"topoana.exe cardFileName\". ",
            "section": "Execution of the program",
            "paragraph_rank": 26,
            "section_rank": 8
        },
        {
            "text": "This subsection introduces the essential items for the input, basic functionality, and output of the program. ",
            "section": "Execution of the program",
            "paragraph_rank": 26,
            "section_rank": 8
        },
        {
            "text": "More items that can be set in the card file will be described in the following three sections. ",
            "section": "Execution of the program",
            "paragraph_rank": 26,
            "section_rank": 8
        },
        {
            "text": "Sections 3 and 4 expatiate the available items for the functionalities of the program, and Section 5 presents some optional items for the common settings to control the execution of the program.",
            "section": "Execution of the program",
            "paragraph_rank": 26,
            "section_rank": 8
        },
        {
            "text": "An example of the card file containing the essential items is shown as follows. ",
            "section": "Execution of the program",
            "paragraph_rank": 27,
            "section_rank": 8
        },
        {
            "text": "In the card file, \"#\", \"%\", and the pair of \"{\" and \"}\", are used for commenting, prompting, and grouping, respectively. ",
            "section": "Execution of the program",
            "paragraph_rank": 27,
            "section_rank": 8
        },
        {
            "text": "The first five, sixth, and last items are set for the input, basic functionality, and output of the program, respectively.",
            "section": "Execution of the program",
            "paragraph_rank": 27,
            "section_rank": 8
        },
        {
            "text": "The first item sets the names of the input root files. ",
            "section": "Execution of the program",
            "paragraph_rank": 28,
            "section_rank": 8
        },
        {
            "text": "The names ought to be input one per line without tailing characters, such as comma, semicolon, and period. ",
            "section": "Execution of the program",
            "paragraph_rank": 28,
            "section_rank": 8
        },
        {
            "text": "In the names, both the absolute and relative paths are allowed and wildcards \"[]?*\" are supported, just like those in the root file names input to the method Add() of the class TChain [2]. ",
            "section": "Execution of the program",
            "paragraph_rank": 28,
            "section_rank": 8
        },
        {
            "text": "The second item specifies the TTree name. ",
            "section": "Execution of the program",
            "paragraph_rank": 28,
            "section_rank": 8
        },
        {
            "text": "The following three items set the TBranch names of the three ingredients of the raw topology truth information. ",
            "section": "Execution of the program",
            "paragraph_rank": 28,
            "section_rank": 8
        },
        {
            "text": "Of the first five items, the former two are indispensable, whereas the latter three can be removed or left empty if the input values are identical to the default values indicated in their prompts.",
            "section": "Execution of the program",
            "paragraph_rank": 28,
            "section_rank": 8
        },
        {
            "text": "The sixth item sets the basic functionality of the program, namely the component analysis over decay trees. ",
            "section": "Execution of the program",
            "paragraph_rank": 29,
            "section_rank": 8
        },
        {
            "text": "The item can be replaced or co-exist with other functionality items expatiated in Sections 3 and 4. ",
            "section": "Execution of the program",
            "paragraph_rank": 29,
            "section_rank": 8
        },
        {
            "text": "Here, we note that at least one functionality item has to be specified explicitly in the card file, otherwise the program will terminate soon after its start because no topology analysis to be performed is set up.",
            "section": "Execution of the program",
            "paragraph_rank": 29,
            "section_rank": 8
        },
        {
            "text": "The last item specifies the common name of the output files. ",
            "section": "Execution of the program",
            "paragraph_rank": 30,
            "section_rank": 8
        },
        {
            "text": "Though in different formats, the files are denominated with the same name for the sake of uniformity. ",
            "section": "Execution of the program",
            "paragraph_rank": 30,
            "section_rank": 8
        },
        {
            "text": "They will be introduced in detail in the next subsection. ",
            "section": "Execution of the program",
            "paragraph_rank": 30,
            "section_rank": 8
        },
        {
            "text": "This item is also optional, with the name of the card file as its default input value. ",
            "section": "Execution of the program",
            "paragraph_rank": 30,
            "section_rank": 8
        },
        {
            "text": "It is a good practice to first denominate the card file with the desired common name of the output files and then remove this item or leave it empty.",
            "section": "Execution of the program",
            "paragraph_rank": 30,
            "section_rank": 8
        },
        {
            "text": "To provide a complete description, we list and explain all the essential items in the paragraphs above. ",
            "section": "Execution of the program",
            "paragraph_rank": 31,
            "section_rank": 8
        },
        {
            "text": "However, in practical uses, we suggest removing the optional items if the input values are identical to the default ones. ",
            "section": "Execution of the program",
            "paragraph_rank": 31,
            "section_rank": 8
        },
        {
            "text": "In this way, the contents of the card file will become much more concise, making the use of the program easier and quicker. ",
            "section": "Execution of the program",
            "paragraph_rank": 31,
            "section_rank": 8
        },
        {
            "text": "For example, unless otherwise stated, only the following two items are used to set the essential information in Sections 3, 4, and 5. ",
            "section": "Execution of the program",
            "paragraph_rank": 31,
            "section_rank": 8
        },
        {
            "text": "Performance of the program",
            "section_rank": 9
        },
        {
            "text": "Besides the performance of the used computing systems, the processing rate of the program is largely related to the characteristics of the samples, particularly the average number of generated particles in each event. ",
            "section": "Performance of the program",
            "paragraph_rank": 32,
            "section_rank": 9
        },
        {
            "text": "Figure 4 shows the performance study of the program with the J/\u03c8 sample used in the example of this section as well as the \u03c4 + \u03c4 \u2212 , dd, u\u016b, ss, cc, B + B \u2212 , and B 0B0 samples generated at the peak energy of the \u03a5(4S ) resonance. ",
            "section": "Performance of the program",
            "paragraph_rank": 32,
            "section_rank": 9,
            "ref_spans": [
                {
                    "start": 0,
                    "end": 8,
                    "type": "figure",
                    "ref_id": "fig_5",
                    "text": "Figure 4"
                }
            ]
        },
        {
            "text": "Each of the used samples consists of one hundred thousand events. ",
            "section": "Performance of the program",
            "paragraph_rank": 32,
            "section_rank": 9
        },
        {
            "text": "From the left plot in the figure, for all the samples, the number of elapsed seconds grows linearly with the number of processed entries. ",
            "section": "Performance of the program",
            "paragraph_rank": 32,
            "section_rank": 9
        },
        {
            "text": "This linear pattern is a nice feature. ",
            "section": "Performance of the program",
            "paragraph_rank": 32,
            "section_rank": 9
        },
        {
            "text": "It guarantees the program has a high rate even in the case of processing huge samples. ",
            "section": "Performance of the program",
            "paragraph_rank": 32,
            "section_rank": 9
        },
        {
            "text": "For example, the program can process one hundred thousand J/\u03c8 events within five seconds. ",
            "section": "Performance of the program",
            "paragraph_rank": 32,
            "section_rank": 9
        },
        {
            "text": "Here, we note that the linear pattern is the result of fast searches with unordered maps [9], as we discuss in Section 2.3. ",
            "section": "Performance of the program",
            "paragraph_rank": 32,
            "section_rank": 9
        },
        {
            "text": "On the other hand, the processing rate of the program varies with the processed samples. ",
            "section": "Performance of the program",
            "paragraph_rank": 32,
            "section_rank": 9
        },
        {
            "text": "The right plot in Fig. 4 shows the relationship between the total number of elapsed seconds over the whole sample and the average number of generated particles in an event. ",
            "section": "Performance of the program",
            "paragraph_rank": 32,
            "section_rank": 9,
            "ref_spans": [
                {
                    "start": 18,
                    "end": 24,
                    "type": "figure",
                    "ref_id": "fig_5",
                    "text": "Fig. 4"
                }
            ]
        },
        {
            "text": "Clearly, a linear pattern is also observed in the plot. ",
            "section": "Performance of the program",
            "paragraph_rank": 32,
            "section_rank": 9
        },
        {
            "text": "To be specific, with the average number of generated particles in an event increasing by one, the total number of elapsed seconds over the whole sample increases by about 0.56. ",
            "section": "Performance of the program",
            "paragraph_rank": 32,
            "section_rank": 9
        },
        {
            "text": ": Performance study of the program with the J/\u03c8 sample as well as the \u03c4 + \u03c4 \u2212 , dd, u\u016b, ss, cc, B + B \u2212 , and B 0B0 samples generated at the peak energy of the \u03a5(4S ) resonance. ",
            "section": "Performance of the program",
            "paragraph_rank": 32,
            "section_rank": 9
        },
        {
            "text": "The left plot demonstrates the changing trends of the number of elapsed seconds with respect to the number of processed entries. ",
            "section": "Performance of the program",
            "paragraph_rank": 32,
            "section_rank": 9
        },
        {
            "text": "The right plot illustrates the relationship between the total number of elapsed seconds over the whole sample and the average number of generated particles in an event. ",
            "section": "Performance of the program",
            "paragraph_rank": 32,
            "section_rank": 9
        },
        {
            "text": "In both plots, the dots show the timing data from the standard output of the program, and the lines display the results of fitting linear functions to the data.",
            "section": "Performance of the program",
            "paragraph_rank": 32,
            "section_rank": 9
        },
        {
            "text": "Output of the program",
            "section_rank": 10
        },
        {
            "text": "The program gains the topology information from input data and saves it to output files. ",
            "section": "Output of the program",
            "paragraph_rank": 33,
            "section_rank": 10
        },
        {
            "text": "As mentioned in Section 1, the information includes the types of physics processes and the number of processes in each type, involved both in entire samples and in individual events. ",
            "section": "Output of the program",
            "paragraph_rank": 33,
            "section_rank": 10
        },
        {
            "text": "We refer to the information at the sample level as topology maps. ",
            "section": "Output of the program",
            "paragraph_rank": 33,
            "section_rank": 10
        },
        {
            "text": "In the topology maps, we assign an integer to each type of physics processes as its index. ",
            "section": "Output of the program",
            "paragraph_rank": 33,
            "section_rank": 10
        },
        {
            "text": "We term the indices of processes as well as the numbers of processes involved in each type in the individual events as topology tags.",
            "section": "Output of the program",
            "paragraph_rank": 33,
            "section_rank": 10
        },
        {
            "text": "The program outputs topology maps to three different files: one plain text file, one tex source file, and one pdf file, with the same name specified in the card file. ",
            "section": "Output of the program",
            "paragraph_rank": 34,
            "section_rank": 10
        },
        {
            "text": "For instance, the three files are \"jpsi ta.txt\", \"jpsi ta.tex\", and \"jpsi ta.pdf\" in the example. ",
            "section": "Output of the program",
            "paragraph_rank": 34,
            "section_rank": 10
        },
        {
            "text": "Although in different formats, the three files have the same information. ",
            "section": "Output of the program",
            "paragraph_rank": 34,
            "section_rank": 10
        },
        {
            "text": "The pdf file is the easiest to read. ",
            "section": "Output of the program",
            "paragraph_rank": 34,
            "section_rank": 10
        },
        {
            "text": "It is converted from the tex source file with the command pdflatex. ",
            "section": "Output of the program",
            "paragraph_rank": 34,
            "section_rank": 10
        },
        {
            "text": "The tex source file is convenient to us if we want to change the style of the pdf file to our taste and when we need to copy and paste (parts of) the topology maps to our slides, papers, and so on. ",
            "section": "Output of the program",
            "paragraph_rank": 34,
            "section_rank": 10
        },
        {
            "text": "For example, all of the tables displaying topology maps in this paper are taken from associated tex source files. ",
            "section": "Output of the program",
            "paragraph_rank": 34,
            "section_rank": 10
        },
        {
            "text": "The plain text file has its own advantage, because the topology maps in it can be checked with text processing commands as well as text editors, and can be used on some occasions as input to the functionality items (see Sections 3 and 4 for details) of another card file.",
            "section": "Output of the program",
            "paragraph_rank": 34,
            "section_rank": 10
        },
        {
            "text": "In addition to the three files for topology maps, one or more root files are output to save topology tags. ",
            "section": "Output of the program",
            "paragraph_rank": 35,
            "section_rank": 10
        },
        {
            "text": "The root files only include one TTree object, which is entirely the same as that in the input root files, except for the topology tags inserted in all of its entries. ",
            "section": "Output of the program",
            "paragraph_rank": 35,
            "section_rank": 10
        },
        {
            "text": "The number of root files depends on the size of output data. ",
            "section": "Output of the program",
            "paragraph_rank": 35,
            "section_rank": 10
        },
        {
            "text": "The program switches to one new root file whenever the size of the TTree object in memory exceeds 3 GB. ",
            "section": "Output of the program",
            "paragraph_rank": 35,
            "section_rank": 10
        },
        {
            "text": "In the case of the size less than 3 GB, only one root file is output. ",
            "section": "Output of the program",
            "paragraph_rank": 35,
            "section_rank": 10
        },
        {
            "text": "While the sole or first root file has the same name as the three files above, more possible root files are denominated with the suffix \" n\" (n=1, 2, 3, and so on) appended to the name. ",
            "section": "Output of the program",
            "paragraph_rank": 35,
            "section_rank": 10
        },
        {
            "text": "In the example, the first root file is \"jpsi ta.root\", and more possible root files would be \"jpsi ta 1.root\", \"jpsi ta 2.root\", \"jpsi ta 3.root\", and so on. ",
            "section": "Output of the program",
            "paragraph_rank": 35,
            "section_rank": 10
        },
        {
            "text": "In the example of the previous subsection, the program conducts its basic functionality, namely the component analysis over decay trees. ",
            "section": "Output of the program",
            "paragraph_rank": 36,
            "section_rank": 10
        },
        {
            "text": "From the 100000 events of the input sample, the program recognizes 17424 decay trees and outputs all of them to the plain text, tex source, and pdf files. ",
            "section": "Output of the program",
            "paragraph_rank": 36,
            "section_rank": 10
        },
        {
            "text": "Table 1 only shows the top ten decay trees and their respective final states listed in the output pdf file. ",
            "section": "Output of the program",
            "paragraph_rank": 36,
            "section_rank": 10,
            "ref_spans": [
                {
                    "start": 0,
                    "end": 7,
                    "type": "table",
                    "ref_id": "tab_3",
                    "text": "Table 1"
                }
            ]
        },
        {
            "text": "With the help of the symbolic expressions, the components of the sample are clearly displayed in the table, which brings great convenience to us in examining the signals and backgrounds involved in the sample. ",
            "section": "Output of the program",
            "paragraph_rank": 36,
            "section_rank": 10
        },
        {
            "text": "In the table, \"rowNo\", \"iDcyTr\", \"nEtr\", and \"nCEtr\" are abbreviations for the row number, index of decay tree, number of entries of decay tree, and number of the cumulative entries from the first to the current decay trees, respectively. ",
            "section": "Output of the program",
            "paragraph_rank": 36,
            "section_rank": 10
        },
        {
            "text": "The values of \"iDcyTr\" are assigned from small to large in the program but listed according to the values of \"nEtr\" from large to small in the table. ",
            "section": "Output of the program",
            "paragraph_rank": 36,
            "section_rank": 10
        },
        {
            "text": "This is the reason why they are not in natural order like the values of \"rowNo\". ",
            "section": "Output of the program",
            "paragraph_rank": 36,
            "section_rank": 10
        },
        {
            "text": "Since J/\u03c8 is the only root particle for the J/\u03c8 sample, the production branch e + e \u2212 \u2192 J/\u03c8 is omitted to save page space. ",
            "section": "Output of the program",
            "paragraph_rank": 36,
            "section_rank": 10
        },
        {
            "text": "Similar rules also apply to other samples with only one root particle. ",
            "section": "Output of the program",
            "paragraph_rank": 36,
            "section_rank": 10
        },
        {
            "text": "Considering \u03c0 0 has a very large production rate and approximatively 99% of it decays to \u03b3\u03b3, the program is designed to discard the decay \u03c0 0 \u2192 \u03b3\u03b3 by default at the early phase of processing the input data. ",
            "section": "Output of the program",
            "paragraph_rank": 36,
            "section_rank": 10
        },
        {
            "text": "As a result, \u03c0 0 \u2192 \u03b3\u03b3 does not show itself in the table. ",
            "section": "Output of the program",
            "paragraph_rank": 36,
            "section_rank": 10
        },
        {
            "text": "Besides, the superscripts \" f \" and \"F\" in \u03b3 f and \u03b3 F indicate the final state radiation effect. ",
            "section": "Output of the program",
            "paragraph_rank": 36,
            "section_rank": 10
        },
        {
            "text": "Here, we note that \u03b3 f is translated from a special input PDG code (\u221222 in this example), and \u03b3 F owns a normal PDG code 22 and meanwhile has at least one e \u00b1 , \u00b5 \u00b1 , \u03c0 \u00b1 , K \u00b1 , p, orp sister.",
            "section": "Output of the program",
            "paragraph_rank": 36,
            "section_rank": 10
        },
        {
            "text": "In the table, \"iDcyTr\" is the topology tag for decay trees. ",
            "section": "Output of the program",
            "paragraph_rank": 37,
            "section_rank": 10
        },
        {
            "text": "Thus, it is also saved in the TTree objects of the output root file, together with other quantities for physics analysis. ",
            "section": "Output of the program",
            "paragraph_rank": 37,
            "section_rank": 10
        },
        {
            "text": "Therefore, it can be used to pick out the entries of specific decay trees and then examine the distributions of the other quantities over the decay trees. ",
            "section": "Output of the program",
            "paragraph_rank": 37,
            "section_rank": 10
        },
        {
            "text": "In the example, besides the raw topology truth information, only a random variable following the standardized normal distribution, namely X, is stored in the input root files and thus copied by default to the output root file. ",
            "section": "Output of the program",
            "paragraph_rank": 37,
            "section_rank": 10
        },
        {
            "text": "Though not a genuine variable for physics analysis, X is quite good to illustrate the usage of the topology tag. ",
            "section": "Output of the program",
            "paragraph_rank": 37,
            "section_rank": 10
        },
        {
            "text": "Figure 5: Distribution of X accumulated over the top ten decay trees. ",
            "section": "Output of the program",
            "paragraph_rank": 38,
            "section_rank": 10
        },
        {
            "text": "In the legend entry \"J/\u03c8 \u2192 \u03c1 + \u03c1 \u2212 \u03c9, ...\", the dots \"...\" represent the secondary decay branches:",
            "section": "Output of the program",
            "paragraph_rank": 38,
            "section_rank": 10
        },
        {
            "text": "examples/in the paper/ex for tb 01/draw X/v2/draw X.C, where, for example, a statement equivalent to chain->Draw(\"X >>h0\", \"iDcyTr==6\") is used to import X over the decay tree J/\u03c8 \u2192 \u00b5 + \u00b5 \u2212 from the output root file to the histogram named h0. ",
            "section": "Output of the program",
            "paragraph_rank": 39,
            "section_rank": 10
        },
        {
            "text": "With such a figure, we can clearly see the contribution of each decay tree. ",
            "section": "Output of the program",
            "paragraph_rank": 39,
            "section_rank": 10
        },
        {
            "text": "Particularly, we can get to know whether a decay tree has a peak contribution or a contribution mainly distributed in a different region. ",
            "section": "Output of the program",
            "paragraph_rank": 39,
            "section_rank": 10
        },
        {
            "text": "Based on these distributions, we can get a better understanding of our signals and backgrounds, and thus optimize event selection criteria by applying new requirements on the displayed quantities.",
            "section": "Output of the program",
            "paragraph_rank": 39,
            "section_rank": 10
        },
        {
            "text": "Validation of the program",
            "section_rank": 11
        },
        {
            "text": "The decay trees displayed in Table 1 are relatively simple, and we can check their correctness by examining the input data directly. ",
            "section": "Validation of the program",
            "paragraph_rank": 40,
            "section_rank": 11,
            "ref_spans": [
                {
                    "start": 29,
                    "end": 36,
                    "type": "table",
                    "ref_id": "tab_3",
                    "text": "Table 1"
                }
            ]
        },
        {
            "text": "To validate the program generally, we need to do input and output checks, where some arbitrary physics processes are generated as the input of the program. ",
            "section": "Validation of the program",
            "paragraph_rank": 40,
            "section_rank": 11
        },
        {
            "text": "The output has to be consistent with the input; otherwise, there must be some bugs in the program and we have to fix them. ",
            "section": "Validation of the program",
            "paragraph_rank": 40,
            "section_rank": 11
        },
        {
            "text": "A large number of such checks have been performed in the development and application of the program, and some of them can be found under the sub-directory \"examples/validation\" of the package. ",
            "section": "Validation of the program",
            "paragraph_rank": 40,
            "section_rank": 11
        },
        {
            "text": "These checks are divided into two groups: standalone and combined. ",
            "section": "Validation of the program",
            "paragraph_rank": 40,
            "section_rank": 11
        },
        {
            "text": "In the standalone checks, forty exclusive J/\u03c8 and \u03a5(4S ) decays modeled with the EvtGen [10] generator are used to test the functionality of resolving decay trees. ",
            "section": "Validation of the program",
            "paragraph_rank": 40,
            "section_rank": 11,
            "ref_spans": [
                {
                    "start": 88,
                    "end": 92,
                    "type": "bibr",
                    "ref_id": "b7",
                    "text": "[10]"
                }
            ]
        },
        {
            "text": "In the combined checks, randomly combined samples of these exclusive decays are used for verifying the functionalities of counting and tagging decay trees. ",
            "section": "Validation of the program",
            "paragraph_rank": 40,
            "section_rank": 11
        },
        {
            "text": "The output agrees with the input in all the checks, which indicates the correctness of the program.",
            "section": "Validation of the program",
            "paragraph_rank": 40,
            "section_rank": 11
        },
        {
            "text": "Component analysis",
            "section_rank": 12
        },
        {
            "text": "Component analysis is the primary functionality of the program. ",
            "section": "Component analysis",
            "paragraph_rank": 41,
            "section_rank": 12
        },
        {
            "text": "It is developed mainly for the background analysis involved in our physics studies. ",
            "section": "Component analysis",
            "paragraph_rank": 41,
            "section_rank": 12
        },
        {
            "text": "We perform it over decay trees in the previous example. ",
            "section": "Component analysis",
            "paragraph_rank": 41,
            "section_rank": 12
        },
        {
            "text": "Also, it can be carried out as follows: over decay initial-final states; with specified particles to check their decay branches, cascade decay branches, and decay final states; with specified inclusive decay branches to examine their exclusive components; and with specified intermediate-resonance-allowed (IRA) decay branches to investigate their inner structures. ",
            "section": "Component analysis",
            "paragraph_rank": 41,
            "section_rank": 12
        },
        {
            "text": "In this paper, we only introduce the four representative kinds of component analysis, with each in a subsection (for other kinds of component analysis, please see the user guide attached in the package of the program). ",
            "section": "Component analysis",
            "paragraph_rank": 41,
            "section_rank": 12
        },
        {
            "text": "For each kind of component analysis, one item is designed and implemented in the program to set related parameters. ",
            "section": "Component analysis",
            "paragraph_rank": 41,
            "section_rank": 12
        },
        {
            "text": "In each subsection, we take an example to demonstrate the corresponding setting item and show the resulting topology map. ",
            "section": "Component analysis",
            "paragraph_rank": 41,
            "section_rank": 12
        },
        {
            "text": "For easy exposition, all of the essential topology tags involved in the four representative kinds of component analysis functionalities are presented in another separate subsection, namely the last subsection.",
            "section": "Component analysis",
            "paragraph_rank": 41,
            "section_rank": 12
        },
        {
            "text": "Similar to the case over decay trees, to perform the component analysis over decay initialfinal states, we only need to input a positive option \"Y\" to the corresponding item. ",
            "section": "Component analysis",
            "paragraph_rank": 42,
            "section_rank": 12
        },
        {
            "text": "Different from the former two kinds, to carry out the latter five kinds of component analysis, we have to explicitly specify one or more desired particles, inclusive decay branches, or IRA decay branches in the associated items. ",
            "section": "Component analysis",
            "paragraph_rank": 42,
            "section_rank": 12
        },
        {
            "text": "In the following examples, two particles or decay branches are set to illustrate the use of these items, but only the topology map related to one of them is shown to save space in the paper.",
            "section": "Component analysis",
            "paragraph_rank": 42,
            "section_rank": 12
        },
        {
            "text": "In addition to the indispensable parameters, two sorts of common optional parameters can be set in the items. ",
            "section": "Component analysis",
            "paragraph_rank": 43,
            "section_rank": 12
        },
        {
            "text": "The first sort is designed for all the seven kinds of component analysis to restrict the maximum number of components output to the plain text, tex source, and pdf files. ",
            "section": "Component analysis",
            "paragraph_rank": 43,
            "section_rank": 12
        },
        {
            "text": "Without the optional parameters, all components will be output. ",
            "section": "Component analysis",
            "paragraph_rank": 43,
            "section_rank": 12
        },
        {
            "text": "This is fine if the number of components is not massive. ",
            "section": "Component analysis",
            "paragraph_rank": 43,
            "section_rank": 12
        },
        {
            "text": "In cases of too many (around ten thousand or more) components, it takes a long time for the program to output the components to the plain text and tex source files as well as to get the pdf file from the tex source file. ",
            "section": "Component analysis",
            "paragraph_rank": 43,
            "section_rank": 12
        },
        {
            "text": "In such cases, it also takes up a large disk space to save these components in the output files. ",
            "section": "Component analysis",
            "paragraph_rank": 43,
            "section_rank": 12
        },
        {
            "text": "Considering further that the posterior components are generally unimportant and our time and energy to examine them are limited, it is better to set a maximum to the number of output components. ",
            "section": "Component analysis",
            "paragraph_rank": 43,
            "section_rank": 12
        },
        {
            "text": "To save space in the paper, we set the maximum number to five in the following examples.",
            "section": "Component analysis",
            "paragraph_rank": 43,
            "section_rank": 12
        },
        {
            "text": "The second sort of optional parameters are developed for the latter five kinds of component analysis to assign meaningful aliases to the specified particles, inclusive decay branches, and IRA decay branches. ",
            "section": "Component analysis",
            "paragraph_rank": 44,
            "section_rank": 12
        },
        {
            "text": "By default, the indices 0, 1, 2, and so on are used to tag the particles and decay branches in the names of the TBranch objects appended in the TTree object of the output root files. ",
            "section": "Component analysis",
            "paragraph_rank": 44,
            "section_rank": 12
        },
        {
            "text": "This is fine, but it is significative to replace the indices with meaningful aliases, particularly in cases of many specified particles or decay branches.",
            "section": "Component analysis",
            "paragraph_rank": 44,
            "section_rank": 12
        },
        {
            "text": "Decay trees",
            "section_rank": 13
        },
        {
            "text": "Component analysis over decay trees is the basic kind of topology analysis. ",
            "section": "Decay trees",
            "paragraph_rank": 45,
            "section_rank": 13
        },
        {
            "text": "It is quite useful to study the backgrounds involved in our research works where the signals are the complete decay trees fully reconstructed from final state particles. ",
            "section": "Decay trees",
            "paragraph_rank": 45,
            "section_rank": 13
        },
        {
            "text": "It has already been widely performed in the BESIII experiment, as illustrated in the previous section with the J/\u03c8 example. ",
            "section": "Decay trees",
            "paragraph_rank": 45,
            "section_rank": 13
        },
        {
            "text": "This subsection introduces it further with the available optional settings using the \u03a5(4S ) sample. ",
            "section": "Decay trees",
            "paragraph_rank": 45,
            "section_rank": 13
        },
        {
            "text": "The following example shows the associated item with the maximum number of output components set to five. ",
            "section": "Decay trees",
            "paragraph_rank": 45,
            "section_rank": 13
        },
        {
            "text": "In the item, a third parameter is also filled and set to \"Y\". ",
            "section": "Decay trees",
            "paragraph_rank": 45,
            "section_rank": 13
        },
        {
            "text": "With the setting, the decay final states in the output pdf file are put under their respective decay trees, rather than in a column next to that for decay trees. ",
            "section": "Decay trees",
            "paragraph_rank": 45,
            "section_rank": 13
        },
        {
            "text": "It is recommended to use this optional parameter in cases there are too many (about ten or more) particles in some final states. ",
            "section": "Decay trees",
            "paragraph_rank": 45,
            "section_rank": 13
        },
        {
            "text": "Here, we note that the symbol \"\u2212\" can be used as a placeholder for the maximum number of output components, if only the third parameter is desired. ",
            "section": "Decay trees",
            "paragraph_rank": 45,
            "section_rank": 13
        },
        {
            "text": "% Component analysis -decay trees { Y 5 Y } Component analysis over decay trees is one kind of the most time-consuming topology analysis tasks. ",
            "section": "Decay trees",
            "paragraph_rank": 45,
            "section_rank": 13
        },
        {
            "text": "To check further the efficiency of the program, the progress of running this example, in addition to the example in Section 2.4, is illustrated in the plots of Fig. 4 as well. ",
            "section": "Decay trees",
            "paragraph_rank": 45,
            "section_rank": 13,
            "ref_spans": [
                {
                    "start": 160,
                    "end": 166,
                    "type": "figure",
                    "ref_id": "fig_5",
                    "text": "Fig. 4"
                }
            ]
        },
        {
            "text": "In these plots, the timing data from this example are marked with the legend entry \"B 0B0 \". ",
            "section": "Decay trees",
            "paragraph_rank": 45,
            "section_rank": 13
        },
        {
            "text": "Since the decay of the \u03a5(4S ) resonance is more complex than that of the J/\u03c8 resonance, it takes more than twenty seconds for the program to process one hundred thousand events in this example. ",
            "section": "Decay trees",
            "paragraph_rank": 45,
            "section_rank": 13
        },
        {
            "text": "Nonetheless, the program still has a high processing rate. ",
            "section": "Decay trees",
            "paragraph_rank": 45,
            "section_rank": 13
        },
        {
            "text": "Table 2 shows the decay trees. ",
            "section": "Decay trees",
            "paragraph_rank": 45,
            "section_rank": 13,
            "ref_spans": [
                {
                    "start": 0,
                    "end": 7,
                    "type": "table",
                    "ref_id": "tab_4",
                    "text": "Table 2"
                }
            ]
        },
        {
            "text": "In the table, while the first five decay trees are listed exclusively in the main part, the rest decay trees are only summarized inclusively at the bottom row. ",
            "section": "Decay trees",
            "paragraph_rank": 45,
            "section_rank": 13
        },
        {
            "text": "Here, we note that the events are not densely populated over the first five decay trees because the inclusive \u03a5(4S ) sample used here is not selected beforehand with any requirements. ",
            "section": "Decay trees",
            "paragraph_rank": 45,
            "section_rank": 13
        },
        {
            "text": "In the symbolic expressions of decay initial-final states, the dashed right arrow ( ) instead of the plain right arrow (\u2192) is used, in order to reflect that the initial states do not necessarily decay to the final states in a direct way. ",
            "section": "Decay trees",
            "paragraph_rank": 45,
            "section_rank": 13
        },
        {
            "text": "e + e + \u03bd e \u03bd e \u03c0 0 \u03c0 0 ",
            "section": "Decay trees",
            "paragraph_rank": 46,
            "section_rank": 13
        },
        {
            "text": "Decay initial-final states",
            "section_rank": 14
        },
        {
            "text": "On some occasions, we need to investigate the decay initial-final states of backgrounds for some sophisticated physics analyses. ",
            "section": "Decay initial-final states",
            "paragraph_rank": 47,
            "section_rank": 14
        },
        {
            "text": "Particularly, it is necessary to differentiate the following two fundamental types of backgrounds: the one with the same initial-final states as the signal, and the other with different initial-final states from the signal. ",
            "section": "Decay initial-final states",
            "paragraph_rank": 47,
            "section_rank": 14
        },
        {
            "text": "While the latter type of backgrounds needs to be suppressed as much as possible, the former type usually needs to be kept to study more physical effects, for example, the interference effect. ",
            "section": "Decay initial-final states",
            "paragraph_rank": 47,
            "section_rank": 14
        },
        {
            "text": "Besides, examining the decay initial-final states of backgrounds sheds light on the misjudgment of final state particles at the level of signal candidates. ",
            "section": "Decay initial-final states",
            "paragraph_rank": 47,
            "section_rank": 14
        },
        {
            "text": "Below is an example demonstrating the related item with the maximum number of output components set to five.",
            "section": "Decay initial-final states",
            "paragraph_rank": 47,
            "section_rank": 14
        },
        {
            "text": "% Component analysis -decay initial-final states",
            "section_rank": 15
        },
        {
            "text": "The decay initial-final states are displayed in Table 3. ",
            "section": "% Component analysis -decay initial-final states",
            "paragraph_rank": 48,
            "section_rank": 15,
            "ref_spans": [
                {
                    "start": 48,
                    "end": 55,
                    "type": "table",
                    "ref_id": "tab_6",
                    "text": "Table 3"
                }
            ]
        },
        {
            "text": "The layout of the table is similar to that of Table 2, which shows the decay trees.  ",
            "section": "% Component analysis -decay initial-final states",
            "paragraph_rank": 48,
            "section_rank": 15,
            "ref_spans": [
                {
                    "start": 46,
                    "end": 53,
                    "type": "table",
                    "ref_id": "tab_4",
                    "text": "Table 2"
                }
            ]
        },
        {
            "text": "Decay branches of particles",
            "section_rank": 16
        },
        {
            "text": "The invariant mass constraint is one of the most frequently used event selection requirements in high energy physics experiments. ",
            "section": "Decay branches of particles",
            "paragraph_rank": 49,
            "section_rank": 16
        },
        {
            "text": "With the requirement applied to certain particle, the main backgrounds (especially the peaking ones) to its signal decay mode are very likely to be its other decay modes. ",
            "section": "Decay branches of particles",
            "paragraph_rank": 49,
            "section_rank": 16
        },
        {
            "text": "In this case, it is significant to examine the decay branches of the particle. ",
            "section": "Decay branches of particles",
            "paragraph_rank": 49,
            "section_rank": 16
        },
        {
            "text": "The following example shows the associated item with the two particles D * + and J/\u03c8 set as research objects. ",
            "section": "Decay branches of particles",
            "paragraph_rank": 49,
            "section_rank": 16
        },
        {
            "text": "In the item, each row holds the information of a specified particle, and the first, second and third columns are the textual expressions, aliases, and maximum numbers of output components, respectively. ",
            "section": "Decay branches of particles",
            "paragraph_rank": 49,
            "section_rank": 16
        },
        {
            "text": "As we introduce at the beginning part of this section, the aliases and maximum numbers of output components are both optional. ",
            "section": "Decay branches of particles",
            "paragraph_rank": 49,
            "section_rank": 16
        },
        {
            "text": "Here, we note that the symbol \"\u2212\" can also be used as a placeholder for an unassigned alias, if only the maximum number of output components is desired.  ",
            "section": "Decay branches of particles",
            "paragraph_rank": 49,
            "section_rank": 16
        },
        {
            "text": "Table 4 shows the decay branches of D * + . ",
            "section": "Decay branches of particles",
            "paragraph_rank": 49,
            "section_rank": 16,
            "ref_spans": [
                {
                    "start": 0,
                    "end": 7,
                    "type": "table",
                    "ref_id": "tab_8",
                    "text": "Table 4"
                }
            ]
        },
        {
            "text": "From the table, only four decay branches of D * + are found in the input inclusive MC sample. ",
            "section": "Decay branches of particles",
            "paragraph_rank": 49,
            "section_rank": 16
        },
        {
            "text": "Since there is likely one or more cases of D * + decays in one input entry, \"nCase\" and \"nCCase\", instead of \"nEtr\" and \"nCEtr\", are used in the table in order to accurately indicate what we are counting are the numbers of D * + decays, rather than the numbers of entries involving the D * + decays. ",
            "section": "Decay branches of particles",
            "paragraph_rank": 49,
            "section_rank": 16
        },
        {
            "text": "It is worth mentioning here that, in addition to decay branches, production branches and mothers of specified particles can also be examined with the program. ",
            "section": "Decay branches of particles",
            "paragraph_rank": 49,
            "section_rank": 16
        },
        {
            "text": "One can make the program execute the two functionalities by replacing \"decay branches\" in the prompt of the item with \"production branches\" and \"mothers\", respectively.",
            "section": "Decay branches of particles",
            "paragraph_rank": 49,
            "section_rank": 16
        },
        {
            "text": "Inclusive decay branches",
            "section_rank": 17
        },
        {
            "text": "In some physics studies, we take inclusive decay branches as signals. ",
            "section": "Inclusive decay branches",
            "paragraph_rank": 50,
            "section_rank": 17
        },
        {
            "text": "In such cases, it is essential to have a basic knowledge of the exclusive components of these inclusive decay branches. ",
            "section": "Inclusive decay branches",
            "paragraph_rank": 50,
            "section_rank": 17
        },
        {
            "text": "Below is an example demonstrating the related item by investigating the exclusive components of the two inclusive decay branchesB 0 \u2192 D * + + anything and B 0 \u2192 K 0 S + anything. ",
            "section": "Inclusive decay branches",
            "paragraph_rank": 50,
            "section_rank": 17
        },
        {
            "text": "In the item, each row holds the information of an inclusive decay branch, and the first, second, and third columns separated with the symbol \"&\" are the textual expressions, aliases, and maximum numbers of output components, respectively. ",
            "section": "Inclusive decay branches",
            "paragraph_rank": 50,
            "section_rank": 17
        },
        {
            "text": "As we introduce at the beginning part of this section, the aliases and maximum numbers of output components are both optional. ",
            "section": "Inclusive decay branches",
            "paragraph_rank": 50,
            "section_rank": 17
        },
        {
            "text": "Here, we note that the symbol \"\u2212\" can be used as a placeholder for an unassigned alias, if only the maximum number of output components is desired.",
            "section": "Inclusive decay branches",
            "paragraph_rank": 50,
            "section_rank": 17
        },
        {
            "text": "% Component analysis -inclusive decay branches",
            "section_rank": 18
        },
        {
            "text": "The exclusive components of B 0 \u2192 K 0 S + anything are displayed in Table 5. ",
            "section": "% Component analysis -inclusive decay branches",
            "paragraph_rank": 51,
            "section_rank": 18,
            "ref_spans": [
                {
                    "start": 68,
                    "end": 75,
                    "type": "table",
                    "ref_id": "tab_9",
                    "text": "Table 5"
                }
            ]
        },
        {
            "text": "From the table, ten exclusive components of the inclusive decay branch are found in the input sample, and the particles denoted with anything are mainly the traditional charmonium states.  ",
            "section": "% Component analysis -inclusive decay branches",
            "paragraph_rank": 51,
            "section_rank": 18
        },
        {
            "text": "Table 6 lists and interprets all of the essential topology tags involved in the four kinds of component analysis functionalities presented in this section. ",
            "section": "% Component analysis -inclusive decay branches",
            "paragraph_rank": 51,
            "section_rank": 18,
            "ref_spans": [
                {
                    "start": 0,
                    "end": 7,
                    "type": "table",
                    "text": "Table 6"
                }
            ]
        },
        {
            "text": "The topology tag for the component analysis over decay initial-final states is iDcyIFSts. ",
            "section": "% Component analysis -inclusive decay branches",
            "paragraph_rank": 51,
            "section_rank": 18
        },
        {
            "text": "It has a similar interpretation as iDcyTr and Table 6: Essential topology tags involved in each kind of component analysis.",
            "section": "% Component analysis -inclusive decay branches",
            "paragraph_rank": 51,
            "section_rank": 18,
            "ref_spans": [
                {
                    "start": 46,
                    "end": 53,
                    "type": "table",
                    "text": "Table 6"
                }
            ]
        },
        {
            "text": "Essential topology tags",
            "section_rank": 19
        },
        {
            "text": "Component type",
            "section_rank": 20
        },
        {
            "text": "Topology tag Interpretation Decay trees iDcyTr index of decay tree Decay initial-final states iDcyIFSts index of decay initial-final states Decay branches of particles nPDcyBr i number of particle i s (or its decay branches) iDcyBrP i j index of decay branch of the j th particle i Inclusive decay branches nIncDcyBr i number of inclusive decay branch i es iDcyBrIncDcyBr i j index of decay branch of the j th inclusive decay branch i is shown in the third column of Table 3. ",
            "section": "Component type",
            "paragraph_rank": 52,
            "section_rank": 20,
            "ref_spans": [
                {
                    "start": 467,
                    "end": 474,
                    "type": "table",
                    "ref_id": "tab_6",
                    "text": "Table 3"
                }
            ]
        },
        {
            "text": "For the latter five kinds of component analysis, there are two sorts of topology tags. ",
            "section": "Component type",
            "paragraph_rank": 52,
            "section_rank": 20
        },
        {
            "text": "The first sort, such as nPDcyBr i, records the number of instances of the i th specified particle or decay branch found in each event. ",
            "section": "Component type",
            "paragraph_rank": 52,
            "section_rank": 20
        },
        {
            "text": "The second sort, for example, iDcyBrP i j, keeps the associated index of the j th found instance of the i th specified particle or decay branch. ",
            "section": "Component type",
            "paragraph_rank": 52,
            "section_rank": 20
        },
        {
            "text": "The indices and the decays they stand for can be found in Tables 4 and 5. ",
            "section": "Component type",
            "paragraph_rank": 52,
            "section_rank": 20,
            "ref_spans": [
                {
                    "start": 58,
                    "end": 73,
                    "type": "table",
                    "ref_id": "tab_8",
                    "text": "Tables 4 and 5."
                }
            ]
        },
        {
            "text": "In the topology tags, \"i\" in \" i\" is the default index of the specified particle or decay branch, and it ranges from 0 (included) to the number of specified particles or decay branches (excluded). ",
            "section": "Component type",
            "paragraph_rank": 52,
            "section_rank": 20
        },
        {
            "text": "If the alias of the particle or decay branch is also specified, the index \"i\" will be replaced with the alias. ",
            "section": "Component type",
            "paragraph_rank": 52,
            "section_rank": 20
        },
        {
            "text": "For example, since \"Dsp\" and \"Jpsi\" are set as the aliases of D * + and J/\u03c8 in the component analysis over their decay branches, the specialized topology tags nPDcyBr Dsp and nPDcyBr Jpsi, instead of the default ones nPDcyBr 0 and nPDcyBr 1, are used to store the numbers of D * + and J/\u03c8 found in each event.",
            "section": "Component type",
            "paragraph_rank": 52,
            "section_rank": 20
        },
        {
            "text": "Besides, \"j\" in \" j\" is the default index of the found instance of certain particle or decay branch in an event, and it ranges from 0 (included) to the sample-level maximum of the number of instances found in each event (excluded). ",
            "section": "Component type",
            "paragraph_rank": 53,
            "section_rank": 20
        },
        {
            "text": "For example, the maximum of the number of D * + found in each event is two for the whole sample, and thus two topology tags iDcyBrP Dsp 0 and iDcyBrP Dsp 1 are employed to store the indices of D * + decay branches. ",
            "section": "Component type",
            "paragraph_rank": 53,
            "section_rank": 20
        },
        {
            "text": "These indices range from 0 (included) to the number of the types of D * + decay branches found in the samples (excluded). ",
            "section": "Component type",
            "paragraph_rank": 53,
            "section_rank": 20
        },
        {
            "text": "In the events with only one D * + , iDcyBrP Dsp 1 is assigned with the default value \u22121; in the events that have no D * + , the default value \u22121 is assigned to both iDcyBrP Dsp 0 and iDcyBrP Dsp 1.",
            "section": "Component type",
            "paragraph_rank": 53,
            "section_rank": 20
        },
        {
            "text": "Signal identification",
            "section_rank": 21
        },
        {
            "text": "Signal identification is the other functionality of the program. ",
            "section": "Signal identification",
            "paragraph_rank": 54,
            "section_rank": 21
        },
        {
            "text": "Though relatively simple, it can help us identify the \"signals\" we desire directly, quickly, and easily. ",
            "section": "Signal identification",
            "paragraph_rank": 54,
            "section_rank": 21
        },
        {
            "text": "Here, the \"signals\" are not confined to the authentic signals in our research works but can be any physics processes of interests, particularly some important backgrounds we concern. ",
            "section": "Signal identification",
            "paragraph_rank": 54,
            "section_rank": 21
        },
        {
            "text": "At present, the seven basic kinds of signals that can be identified with the program are as follows: (1) decay trees, (2) decay initialfinal states, (3) particles, (4) (regular) decay branches, (5) cascade decay branches, (6) inclusive decay branches, and (7) IRA decay branches. ",
            "section": "Signal identification",
            "paragraph_rank": 54,
            "section_rank": 21
        },
        {
            "text": "For each kind of signals, one item is developed to specify related parameters. ",
            "section": "Signal identification",
            "paragraph_rank": 54,
            "section_rank": 21
        },
        {
            "text": "In this paper, we only introduce the former four kinds of signal identification, with each in a subsection (for the latter three kinds of signal identification, please see the user guide attached in the package of the program). ",
            "section": "Signal identification",
            "paragraph_rank": 54,
            "section_rank": 21
        },
        {
            "text": "In each subsection, we take an example to demonstrate the related setting item and show the obtained topology map. ",
            "section": "Signal identification",
            "paragraph_rank": 54,
            "section_rank": 21
        },
        {
            "text": "For easy exposition, all of the essential topology tags involved in the former four kinds of signal identification functionalities are presented in another separate subsection, that is, the last subsection.",
            "section": "Signal identification",
            "paragraph_rank": 54,
            "section_rank": 21
        },
        {
            "text": "Similar to the cases of the latter five kinds of component analysis, one or more signals can be specified in each of the signal identification items, and two signals are set in the following examples to illustrate the use of the items. ",
            "section": "Signal identification",
            "paragraph_rank": 55,
            "section_rank": 21
        },
        {
            "text": "Besides, meaning aliases can also be optionally assigned to the specified signals so as to better tag them in the names of the TBranch objects appended in the TTree object of the output root files.",
            "section": "Signal identification",
            "paragraph_rank": 55,
            "section_rank": 21
        },
        {
            "text": "Decay trees",
            "section_rank": 22
        },
        {
            "text": "Sometimes, we need to identify certain decay trees. ",
            "section": "Decay trees",
            "paragraph_rank": 56,
            "section_rank": 22
        },
        {
            "text": "The following example shows the associated item with the first two decay trees listed in Table 2 set as signals. ",
            "section": "Decay trees",
            "paragraph_rank": 56,
            "section_rank": 22,
            "ref_spans": [
                {
                    "start": 89,
                    "end": 96,
                    "type": "table",
                    "ref_id": "tab_4",
                    "text": "Table 2"
                }
            ]
        },
        {
            "text": "In the item, each row holds a decay branch in the decay trees, and the first, second, and third columns separated with the symbol \"&\" are the indices, textual expressions, and mother indices of the decay branches, respectively. ",
            "section": "Decay trees",
            "paragraph_rank": 56,
            "section_rank": 22
        },
        {
            "text": "The decay branches with index 0 indicate the beginning of new decay trees, and their mother indices are equal to \u22121, suggesting they have no mother branches because they are the first decay branches of the decay trees. ",
            "section": "Decay trees",
            "paragraph_rank": 56,
            "section_rank": 22
        },
        {
            "text": "Besides, the name of each decay tree can be optionally filled in the fourth column of its first decay branch. ",
            "section": "Decay trees",
            "paragraph_rank": 56,
            "section_rank": 22
        },
        {
            "text": "Similar to the third parameter in the item for the component analysis over decay trees (see Section 3.1), a \"Y\" can be optionally filled in the fifth column of the first decay branch of the first decay tree, to adjust the positions of decay final states in the output pdf file. ",
            "section": "Decay trees",
            "paragraph_rank": 56,
            "section_rank": 22
        },
        {
            "text": "Table 7 shows the resulting topology map. ",
            "section": "Decay trees",
            "paragraph_rank": 56,
            "section_rank": 22,
            "ref_spans": [
                {
                    "start": 0,
                    "end": 7,
                    "type": "table",
                    "ref_id": "tab_10",
                    "text": "Table 7"
                }
            ]
        },
        {
            "text": "The results are the same as those displayed in the first two rows of Table 2. ",
            "section": "Decay trees",
            "paragraph_rank": 56,
            "section_rank": 22
        },
        {
            "text": "Decay initial-final states",
            "section_rank": 23
        },
        {
            "text": "In some cases, we have an interest in some decay initial-final states. ",
            "section": "Decay initial-final states",
            "paragraph_rank": 57,
            "section_rank": 23
        },
        {
            "text": "Below is an example demonstrating the related item by taking the first two decay initial-final states listed in Table 3 as signals. ",
            "section": "Decay initial-final states",
            "paragraph_rank": 57,
            "section_rank": 23,
            "ref_spans": [
                {
                    "start": 112,
                    "end": 119,
                    "type": "table",
                    "ref_id": "tab_6",
                    "text": "Table 3"
                }
            ]
        },
        {
            "text": "Similar to IRA decay branches, decay initial-final states look like inclusive decay branches. ",
            "section": "Decay initial-final states",
            "paragraph_rank": 57,
            "section_rank": 23
        },
        {
            "text": "Hence, except that only two columns are involved in the item, the format of the input to the item for decay initial-final states is identical to that for the component analysis over inclusive decay branches, which is introduced in Section 3.4. ",
            "section": "Decay initial-final states",
            "paragraph_rank": 57,
            "section_rank": 23
        },
        {
            "text": "As we can see from the example, the numbers of identical particles are supported to be written in front of their textual names in order to simplify the textual expressions of the final states. ",
            "section": "Decay initial-final states",
            "paragraph_rank": 57,
            "section_rank": 23
        },
        {
            "text": "The obtained topology map is displayed in Table 8. ",
            "section": "Decay initial-final states",
            "paragraph_rank": 57,
            "section_rank": 23,
            "ref_spans": [
                {
                    "start": 42,
                    "end": 49,
                    "type": "table",
                    "ref_id": "tab_11",
                    "text": "Table 8"
                }
            ]
        },
        {
            "text": "The results are identical to those shown in the first two rows of Table 3. ",
            "section": "Decay initial-final states",
            "paragraph_rank": 57,
            "section_rank": 23,
            "ref_spans": [
                {
                    "start": 66,
                    "end": 73,
                    "type": "table",
                    "ref_id": "tab_6",
                    "text": "Table 3"
                }
            ]
        },
        {
            "text": "Particles",
            "section_rank": 24
        },
        {
            "text": "Occasionally, we may want to identify some particles. ",
            "section": "Particles",
            "paragraph_rank": 58,
            "section_rank": 24
        },
        {
            "text": "The following example shows the associated item with the two particles D * + and J/\u03c8 set as signals. ",
            "section": "Particles",
            "paragraph_rank": 58,
            "section_rank": 24
        },
        {
            "text": "Except that only two columns are involved in the item, the format of the input to the item is identical to that for the component analysis over decay branches of particles, which is introduced in Section 3.3.",
            "section": "Particles",
            "paragraph_rank": 58,
            "section_rank": 24
        },
        {
            "text": "% Signal identification -particles { D*+ Dsp J/psi Jpsi } Table 9 shows the resulting topology map. ",
            "section": "Particles",
            "paragraph_rank": 59,
            "section_rank": 24,
            "ref_spans": [
                {
                    "start": 58,
                    "end": 65,
                    "type": "table",
                    "ref_id": "tab_12",
                    "text": "Table 9"
                }
            ]
        },
        {
            "text": "As a cross-check, the number of D * + s in the table equals that in Table 4. ",
            "section": "Particles",
            "paragraph_rank": 59,
            "section_rank": 24,
            "ref_spans": [
                {
                    "start": 68,
                    "end": 75,
                    "type": "table",
                    "ref_id": "tab_8",
                    "text": "Table 4"
                }
            ]
        },
        {
            "text": "Decay branches",
            "section_rank": 25
        },
        {
            "text": "On some occasions, we have to identify certain regular decay branches. ",
            "section": "Decay branches",
            "paragraph_rank": 60,
            "section_rank": 25
        },
        {
            "text": "Below is an example demonstrating the related item by taking the two decay branchesB 0 \u2192 \u00b5 \u2212\u03bd \u00b5 D * + and B 0 \u2192 K 0 S J/\u03c8 as signals. ",
            "section": "Decay branches",
            "paragraph_rank": 60,
            "section_rank": 25
        },
        {
            "text": "Since regular decay branches also look like inclusive decay branches, except that only two columns are involved in the item, the format of the input to the item for regular decay branches is identical to that for the component analysis over inclusive decay branches, which is introduced in Section 3.4.",
            "section": "Decay branches",
            "paragraph_rank": 60,
            "section_rank": 25
        },
        {
            "text": "% Signal identification -decay branches",
            "section_rank": 26
        },
        {
            "text": "The obtained topology map is displayed Table 10. ",
            "section": "% Signal identification -decay branches",
            "paragraph_rank": 61,
            "section_rank": 26,
            "ref_spans": [
                {
                    "start": 39,
                    "end": 47,
                    "type": "table",
                    "ref_id": "tab_3",
                    "text": "Table 10"
                }
            ]
        },
        {
            "text": "For cross-checks, we note that the number of B 0 \u2192 K 0 S J/\u03c8 in the table is equal to that in the first row of Table 5.  ",
            "section": "% Signal identification -decay branches",
            "paragraph_rank": 61,
            "section_rank": 26,
            "ref_spans": [
                {
                    "start": 111,
                    "end": 118,
                    "type": "table",
                    "ref_id": "tab_9",
                    "text": "Table 5"
                }
            ]
        },
        {
            "text": "Table 11 summarizes and explains all of the essential topology tags involved in the four kinds of signal identification functionalities presented in this section. ",
            "section": "% Signal identification -decay branches",
            "paragraph_rank": 61,
            "section_rank": 26,
            "ref_spans": [
                {
                    "start": 0,
                    "end": 8,
                    "type": "table",
                    "ref_id": "tab_3",
                    "text": "Table 11"
                }
            ]
        },
        {
            "text": "For signal decay trees and signal decay initial-final states, there are two sorts of topology tags. ",
            "section": "% Signal identification -decay branches",
            "paragraph_rank": 61,
            "section_rank": 26
        },
        {
            "text": "The first sort of tags, iSigDcyTr and iSigDcyIFSts, record the default indices of the specified signal decay trees and signal decay initial-final states. ",
            "section": "% Signal identification -decay branches",
            "paragraph_rank": 61,
            "section_rank": 26
        },
        {
            "text": "They have similar interpretations as iDcyTr and iDcyIFSts, and are shown in the third columns of Tables 7 and 8. ",
            "section": "% Signal identification -decay branches",
            "paragraph_rank": 61,
            "section_rank": 26,
            "ref_spans": [
                {
                    "start": 97,
                    "end": 111,
                    "type": "table",
                    "ref_id": "tab_10",
                    "text": "Tables 7 and 8"
                }
            ]
        },
        {
            "text": "The second sort of tags, nameSigDcyTr and nameSigDcyIFSts, save the specified aliases of the signal decay trees and signal decay initialfinal states. ",
            "section": "% Signal identification -decay branches",
            "paragraph_rank": 61,
            "section_rank": 26
        },
        {
            "text": "In cases the aliases are not specified, empty strings will be stored.",
            "section": "% Signal identification -decay branches",
            "paragraph_rank": 61,
            "section_rank": 26
        },
        {
            "text": "Essential topology tags",
            "section_rank": 27
        },
        {
            "text": "For the latter five kinds of signal identification, there is only one sort of topology tags, which records the number of instances of certain specified particle or decay branch found in each event. ",
            "section": "Essential topology tags",
            "paragraph_rank": 62,
            "section_rank": 27
        },
        {
            "text": "Similar to the cases in the latter five kinds of component analysis, in the topology tags, \"i\" in \" i\" is the default index of the specified particle or decay branch, and it ranges from 0 (included) to the number of specified particles or decay branches (excluded). ",
            "section": "Essential topology tags",
            "paragraph_rank": 62,
            "section_rank": 27
        },
        {
            "text": "If the alias of the particle or decay branch is also specified, the index \"i\" will be replaced with the alias. ",
            "section": "Essential topology tags",
            "paragraph_rank": 62,
            "section_rank": 27
        },
        {
            "text": "Common settings",
            "section_rank": 28
        },
        {
            "text": "From Sections 3 and 4, the optional parameters of the functionality items give us more choices and thus help us do our jobs quicker and better. ",
            "section": "Common settings",
            "paragraph_rank": 63,
            "section_rank": 28
        },
        {
            "text": "In addition to these parameters, many optional items are designed and implemented to control the execution of the program in order to meet practical needs. ",
            "section": "Common settings",
            "paragraph_rank": 63,
            "section_rank": 28
        },
        {
            "text": "Unlike the optional parameters, which only affect the individual functionalities to which they belong, the optional items have an impact on all of the functionalities, or at least most of the functionalities. ",
            "section": "Common settings",
            "paragraph_rank": 63,
            "section_rank": 28
        },
        {
            "text": "The current version of the program contains two dozen common setting items on its input, functionalities, and output. ",
            "section": "Common settings",
            "paragraph_rank": 63,
            "section_rank": 28
        },
        {
            "text": "In this paper, we only introduce a part of the items that are crucial to our physics studies (for other items, please see the user guide attached in the package of the program).",
            "section": "Common settings",
            "paragraph_rank": 63,
            "section_rank": 28
        },
        {
            "text": "Settings on input entries",
            "section_rank": 29
        },
        {
            "text": "The program normally processes all of the entries in the input samples, but sometimes only a part of the entries are needed to be (first) processed. ",
            "section": "Settings on input entries",
            "paragraph_rank": 64,
            "section_rank": 29
        },
        {
            "text": "Running the program over a big sample usually takes a long time. ",
            "section": "Settings on input entries",
            "paragraph_rank": 64,
            "section_rank": 29
        },
        {
            "text": "In such a case, it is a good habit to run the program first over a small part of the sample to check possible exceptions, and then over the whole sample if no exceptions are found or after the found exceptions are handled. ",
            "section": "Settings on input entries",
            "paragraph_rank": 64,
            "section_rank": 29
        },
        {
            "text": "Besides, a small number of entries is usually sufficient to do tests in the development of the program. ",
            "section": "Settings on input entries",
            "paragraph_rank": 64,
            "section_rank": 29
        },
        {
            "text": "For these reasons, an item is developed to set up the maximum number of entries to be processed. ",
            "section": "Settings on input entries",
            "paragraph_rank": 64,
            "section_rank": 29
        },
        {
            "text": "Below is an example showing the item with the maximum number set at two thousand.",
            "section": "Settings on input entries",
            "paragraph_rank": 64,
            "section_rank": 29
        },
        {
            "text": "% Maximum number of entries to be processed { 2000 } On some occasions, especially in the course of optimizing selection criteria, we need to run the program only over entries satisfying certain requirements. ",
            "section": "Settings on input entries",
            "paragraph_rank": 65,
            "section_rank": 29
        },
        {
            "text": "For this purpose, an item is developed to select entries. ",
            "section": "Settings on input entries",
            "paragraph_rank": 65,
            "section_rank": 29
        },
        {
            "text": "The following example shows the item with X set in the range (\u22121, 1).",
            "section": "Settings on input entries",
            "paragraph_rank": 65,
            "section_rank": 29
        },
        {
            "text": "Notably, only a single-line selection requirement is supported in the item, like the cases in the methods Draw() [2] and GetEntries() [2] of the class TTree. ",
            "section": "Settings on input entries",
            "paragraph_rank": 66,
            "section_rank": 29
        },
        {
            "text": "In spite of this, such a requirement is able to express any requirement with the help of the parentheses \"()\" as well as the logical symbols \"&&\", \"||\", and \"!\".",
            "section": "Settings on input entries",
            "paragraph_rank": 66,
            "section_rank": 29
        },
        {
            "text": "Setting on input decay branches",
            "section_rank": 30
        },
        {
            "text": "Normally, the program deals with all of the decay branches in every decay tree. ",
            "section": "Setting on input decay branches",
            "paragraph_rank": 67,
            "section_rank": 30
        },
        {
            "text": "However, examining all the branches is not always required in practice. ",
            "section": "Setting on input decay branches",
            "paragraph_rank": 67,
            "section_rank": 30
        },
        {
            "text": "Sometimes, we only concern the first n hierarchies of the branches. ",
            "section": "Setting on input decay branches",
            "paragraph_rank": 67,
            "section_rank": 30
        },
        {
            "text": "Here, the hierarchy reflects the rank of a decay branch in a decay tree. ",
            "section": "Setting on input decay branches",
            "paragraph_rank": 67,
            "section_rank": 30
        },
        {
            "text": "For example, in the decay tree \u03a5 With the setting, the decay branches with hierarchy larger than one will be ignored by the program. ",
            "section": "Setting on input decay branches",
            "paragraph_rank": 67,
            "section_rank": 30
        },
        {
            "text": "For the component analysis over the decay trees of the \u03a5(4S ) sample, only the first hierarchy of \u03a5(4S ) decay branches are analyzed, and the result is shown in Table 12. From the table, not only \u03a5(4S ) \u2192 B 0B0 but also \u03a5(4S ) \u2192 B 0 B 0 and \u03a5(4S ) \u2192B 0B0 are seen because of B 0 -B 0 mixing. ",
            "section": "Setting on input decay branches",
            "paragraph_rank": 67,
            "section_rank": 30,
            "ref_spans": [
                {
                    "start": 161,
                    "end": 169,
                    "type": "table",
                    "ref_id": "tab_3",
                    "text": "Table 12"
                }
            ]
        },
        {
            "text": "Similarly, in the case of the maximum hierarchy set at two, we could get the result of the component analysis over the first two hierarchies of \u03a5(4S ) decay branches, as displayed in Table  13.  ",
            "section": "Setting on input decay branches",
            "paragraph_rank": 67,
            "section_rank": 30,
            "ref_spans": [
                {
                    "start": 183,
                    "end": 192,
                    "type": "table",
                    "ref_id": "tab_3",
                    "text": "Table  13"
                }
            ]
        },
        {
            "text": "Setting on charge conjugation",
            "section_rank": 31
        },
        {
            "text": "Charge conjugation is an important concept in high energy physics. ",
            "section": "Setting on charge conjugation",
            "paragraph_rank": 68,
            "section_rank": 31
        },
        {
            "text": "By default, charge conjugate objects (particles and decays) are processed separately in the program. ",
            "section": "Setting on charge conjugation",
            "paragraph_rank": 68,
            "section_rank": 31
        },
        {
            "text": "However, we need to handle them together in many physics studies because of the sameness between them. ",
            "section": "Setting on charge conjugation",
            "paragraph_rank": 68,
            "section_rank": 31
        },
        {
            "text": "One can have the program process them together with the item below set to \"Y\". ",
            "section": "Setting on charge conjugation",
            "paragraph_rank": 68,
            "section_rank": 31
        },
        {
            "text": "As an example, we carry out the component analysis over the decay branches of D * + and J/\u03c8 with the charge conjugation setting. ",
            "section": "Setting on charge conjugation",
            "paragraph_rank": 68,
            "section_rank": 31
        },
        {
            "text": "The resulting topology map of D * + is displayed in Table  16. ",
            "section": "Setting on charge conjugation",
            "paragraph_rank": 68,
            "section_rank": 31,
            "ref_spans": [
                {
                    "start": 52,
                    "end": 61,
                    "type": "table",
                    "ref_id": "tab_3",
                    "text": "Table  16"
                }
            ]
        },
        {
            "text": "Besides the columns in Table 4, two additional columns with the headers \"nCcCase\" and \"nAllCase\" are inserted in the table. ",
            "section": "Setting on charge conjugation",
            "paragraph_rank": 68,
            "section_rank": 31,
            "ref_spans": [
                {
                    "start": 23,
                    "end": 30,
                    "type": "table",
                    "ref_id": "tab_8",
                    "text": "Table 4"
                }
            ]
        },
        {
            "text": "Here, \"nCcCase\" represents the number of cases involving the charge conjugate particle (D * \u2212 in this table), and \"nAllCase\" is the sum of \"nCase\" and \"nCcCase\". ",
            "section": "Setting on charge conjugation",
            "paragraph_rank": 68,
            "section_rank": 31
        },
        {
            "text": "Table 14: Topology tags related to charge conjugation involved in each kind of component analysis. ",
            "section": "Setting on charge conjugation",
            "paragraph_rank": 68,
            "section_rank": 31,
            "ref_spans": [
                {
                    "start": 0,
                    "end": 8,
                    "type": "table",
                    "ref_id": "tab_3",
                    "text": "Table 14"
                }
            ]
        },
        {
            "text": "For the latter five kinds of component analysis, the topology tags in the (1) and (2) groups are only designed for the self-charge-conjugate and non-self-charge-conjugate particles and decay branches, respectively. ",
            "section": "Setting on charge conjugation",
            "paragraph_rank": 68,
            "section_rank": 31
        },
        {
            "text": "The acronyms \"cc\" and index cc are short for \"charge conjugate\" and \"charge conjugate index\", respectively. ",
            "section": "Setting on charge conjugation",
            "paragraph_rank": 68,
            "section_rank": 31
        },
        {
            "text": "For self-charge-conjugate objects (particles or decays), the charge conjugate indices have the value 0; for non-self-charge-conjugate objects, they have the value 1 or \u22121: while 1 tags the objects presented in the topology maps, \u22121 indicates their charge conjugate objects.",
            "section": "Setting on charge conjugation",
            "paragraph_rank": 68,
            "section_rank": 31
        },
        {
            "text": "Component type",
            "section_rank": 32
        },
        {
            "text": "Topology tag Interpretation Decay trees iCcDcyTr index cc of decay tree Decay initial-final states iCcDcyIFSts index cc of decay initial-final states iCcPDcyBr i index cc of particle i (1) iCcDcyBrP i j index cc of decay branch of the j th particle i Decay branches",
            "section": "Component type",
            "paragraph_rank": 69,
            "section_rank": 32
        },
        {
            "text": "(2) nCcPDcyBr i number of cc particle i s (decay branches) of particles",
            "section": "Component type",
            "paragraph_rank": 70,
            "section_rank": 32
        },
        {
            "text": "(2) iDcyBrCcP i j index of decay branch of the j th cc particle i (2) nAllPDcyBr i number of all particle i s (decay branches)",
            "section": "Component type",
            "paragraph_rank": 71,
            "section_rank": 32
        },
        {
            "text": "Inclusive decay branches iCcIncDcyBr i index cc of inclusive decay branch i (1) iCcDcyBrIncDcyBr i j index cc of decay branch of the j th inclusive decay branch i (2) nCcIncDcyBr i number of cc inclusive decay branch i es (2) iDcyBrCcIncDcyBr i j index of decay branch of the j th cc inclusive decay branch i (2) nAllIncDcyBr i number of all inclusive decay branch i es",
            "section": "Component type",
            "paragraph_rank": 72,
            "section_rank": 32
        },
        {
            "text": "In the example, besides the essential topology tags \"nPDcyBr i\" and \"iDcyBrP i j\", the following three groups of topology tags related to charge conjugation are also inserted in the output root files: (1) \"iCcPDcyBr i\" for all specified particles; (2) \"iCcDcyBrP i j\" only for self-chargeconjugate particles, such as J/\u03c8; (3) \"nCcPDcyBr i\", \"iDcyBrCcP i j\", and \"nAllPDcyBr i\" only for non-self-charge-conjugate particles, such as D * + . ",
            "section": "Component type",
            "paragraph_rank": 73,
            "section_rank": 32
        },
        {
            "text": "Here, \"iCcPDcyBr i\" tags whether the i th particle is self-charge-conjugate. ",
            "section": "Component type",
            "paragraph_rank": 73,
            "section_rank": 32
        },
        {
            "text": "For self-charge-conjugate particles, it has the value 0; for non-self-charge-conjugate particles, it has the value 1.",
            "section": "Component type",
            "paragraph_rank": 73,
            "section_rank": 32
        },
        {
            "text": "The topology tag \"iCcDcyBrP i j\" records the charge conjugation property of the decay branch of the j th instance of the i th particle. ",
            "section": "Component type",
            "paragraph_rank": 74,
            "section_rank": 32
        },
        {
            "text": "For self-charge-conjugate decay branches, it has the value 0; for non-self-charge-conjugate decay branches, it has the value 1 or \u22121: while 1 tags the decay branches listed in the topology maps, \u22121 indicates their charge conjugate decay branches. ",
            "section": "Component type",
            "paragraph_rank": 74,
            "section_rank": 32
        },
        {
            "text": "Whereas the equal values of \"iDcyBrP i j\" for each decay branch and its charge conjugate decay branch indicate their sameness, the opposite values of \"iCcDcyBrP i j\" for them reflect their difference.",
            "section": "Component type",
            "paragraph_rank": 74,
            "section_rank": 32
        },
        {
            "text": "The topology tag \"iDcyBrCcP i j\" is designed for the charge conjugate particle of the i th particle (for D * \u2212 in this example). ",
            "section": "Component type",
            "paragraph_rank": 75,
            "section_rank": 32
        },
        {
            "text": "It has a similar meaning as \"iDcyBrP i j\". ",
            "section": "Component type",
            "paragraph_rank": 75,
            "section_rank": 32
        },
        {
            "text": "Particularly, the values of \"iDcyBrP i j\" and \"iDcyBrCcP i j\" tagging charge conjugate decay branches are equal to each other. ",
            "section": "Component type",
            "paragraph_rank": 75,
            "section_rank": 32
        },
        {
            "text": "The topology tag \"nCcPDcyBr i\" stands for the number of instances (or decay branches) of the charge conjugate particle of the i th particle found in each event, and \"nAllPDcyBr i\" is the sum of \"nPDcyBr i\" and \"nCcPDcyBr i\". ",
            "section": "Component type",
            "paragraph_rank": 75,
            "section_rank": 32
        },
        {
            "text": "Table 15: Topology tags related to charge conjugation involved in each kind of signal identification. ",
            "section": "Component type",
            "paragraph_rank": 75,
            "section_rank": 32,
            "ref_spans": [
                {
                    "start": 0,
                    "end": 8,
                    "type": "table",
                    "ref_id": "tab_3",
                    "text": "Table 15"
                }
            ]
        },
        {
            "text": "For the latter five kinds of signal identification, the topology tags in the (*) groups are only designed for the non-self-charge-conjugate particles and decay branches. ",
            "section": "Component type",
            "paragraph_rank": 75,
            "section_rank": 32
        },
        {
            "text": "The acronyms \"cc\" and index cc are short for \"charge conjugate\" and \"charge conjugate index\", respectively. ",
            "section": "Component type",
            "paragraph_rank": 75,
            "section_rank": 32
        },
        {
            "text": "For self-charge-conjugate objects (particles or decays), the charge conjugate indices have the value 0; for non-self-charge-conjugate objects, they have the value 1 or \u22121: while 1 tags the objects presented in the topology maps, \u22121 indicates their charge conjugate objects.",
            "section": "Component type",
            "paragraph_rank": 75,
            "section_rank": 32
        },
        {
            "text": "Signal type",
            "section_rank": 33
        },
        {
            "text": "Topology tag Interpretation Decay trees iCcSigDcyTr index cc of signal decay tree Decay initial-final states iCcSigDcyIFSts index cc of signal decay initial-final states Particles iCcSigP i index cc of signal particle i (*) nCcSigP i number of cc signal particle i s (*) nAllSigP i number of all signal particle i s Decay branches iCcSigDcyBr i index cc of signal decay branch i (*) nCcSigDcyBr i number of cc signal decay branch i es (*) nAllSigDcyBr i number of all signal decay branch i es ",
            "section": "Signal type",
            "paragraph_rank": 76,
            "section_rank": 33
        },
        {
            "text": "Setting on initial state particles",
            "section_rank": 34
        },
        {
            "text": "In all of the previous examples, the program is applied to the inclusive MC samples in e + e \u2212 colliding experiments. ",
            "section": "Setting on initial state particles",
            "paragraph_rank": 77,
            "section_rank": 34
        },
        {
            "text": "Besides, the program can also be used in other types of high energy experiments, for example, the PANDA experiment [11], a pp annihilation experiment under construction at Darmstadt, Germany. ",
            "section": "Setting on initial state particles",
            "paragraph_rank": 77,
            "section_rank": 34,
            "ref_spans": [
                {
                    "start": 115,
                    "end": 119,
                    "type": "bibr",
                    "ref_id": "b8",
                    "text": "[11]"
                }
            ]
        },
        {
            "text": "On these occasions, we have to specify the right initial state particles with the following item to obtain the proper topology maps. ",
            "section": "Setting on initial state particles",
            "paragraph_rank": 77,
            "section_rank": 34
        },
        {
            "text": "% Initial state particles (Default: e\u2212 e+) { anti-p\u2212 p+ } With the setting, the default initial state e + e \u2212 is replaced by pp, as shown in Table 17, which displays the results of a component analysis over decay trees of a small pp annihilation sample. ",
            "section": "Setting on initial state particles",
            "paragraph_rank": 77,
            "section_rank": 34,
            "ref_spans": [
                {
                    "start": 141,
                    "end": 149,
                    "type": "table",
                    "ref_id": "tab_3",
                    "text": "Table 17"
                }
            ]
        },
        {
            "text": "We develop a program, namely TopoAna, with C++, ROOT, and LaTeX for the event type analysis of inclusive MC samples in high energy physics experiments. ",
            "section": "Setting on initial state particles",
            "paragraph_rank": 77,
            "section_rank": 34,
            "entity_spans": [
                {
                    "start": 58,
                    "end": 64,
                    "type": "software",
                    "rawForm": "LaTeX",
                    "resp": "service",
                    "id": "software-simple-s14"
                }
            ]
        },
        {
            "text": "The program has rich functionalities and aims to solve all kinds of event type analysis tasks. ",
            "section": "Setting on initial state particles",
            "paragraph_rank": 77,
            "section_rank": 34
        },
        {
            "text": "Meanwhile, it is easy to use and has a high processing rate. ",
            "section": "Setting on initial state particles",
            "paragraph_rank": 77,
            "section_rank": 34
        },
        {
            "text": "These features make the program a powerful tool to analyze the backgrounds involved in our research works and to identify the physics processes of interests from the inclusive MC samples.",
            "section": "Setting on initial state particles",
            "paragraph_rank": 77,
            "section_rank": 34
        },
        {
            "text": "Since it does not rely on any specific software frameworks, the program applies to many high energy physics experiments. ",
            "section": "Setting on initial state particles",
            "paragraph_rank": 78,
            "section_rank": 34
        },
        {
            "text": "Up to now, it has been put into use in three experiments at e + e \u2212 colliders: the BESIII, Belle, and Belle II experiments. ",
            "section": "Setting on initial state particles",
            "paragraph_rank": 78,
            "section_rank": 34
        },
        {
            "text": "Besides these experiments, it can also be used in other types of experiments, such as the PANDA experiment, a pp annihilation experiment. ",
            "section": "Setting on initial state particles",
            "paragraph_rank": 78,
            "section_rank": 34
        },
        {
            "text": "Also, the program is applicable to the future e + e \u2212 colliding experiments under research and development, such as the circular electron-positron collider (CEPC) [12,13] experiment in China, the super Charm-\u03c4 factory (SCTF) experiment [14] in Russia, and the super \u03c4-Charm factory (STCF) experiment [15] in China. ",
            "section": "Setting on initial state particles",
            "paragraph_rank": 78,
            "section_rank": 34,
            "ref_spans": [
                {
                    "start": 163,
                    "end": 167,
                    "type": "bibr",
                    "ref_id": "b9",
                    "text": "[12,"
                },
                {
                    "start": 167,
                    "end": 170,
                    "type": "bibr",
                    "ref_id": "b10",
                    "text": "13]"
                },
                {
                    "start": 236,
                    "end": 240,
                    "type": "bibr",
                    "ref_id": "b11",
                    "text": "[14]"
                },
                {
                    "start": 300,
                    "end": 304,
                    "type": "bibr",
                    "ref_id": "b12",
                    "text": "[15]"
                }
            ]
        },
        {
            "text": "These experiments offer wide space for the application of the program.",
            "section": "Setting on initial state particles",
            "paragraph_rank": 78,
            "section_rank": 34
        },
        {
            "text": "On the other hand, we note that the application of the program to some other experiments is limited. ",
            "section": "Setting on initial state particles",
            "paragraph_rank": 79,
            "section_rank": 34
        },
        {
            "text": "For example, thousands of particles can be produced from dozens of pp collisions in an event of the ATLAS [16] and CMS [17] experiments at the LHC [18]; in such cases, there is little point in performing the event type analysis of corresponding MC samples. ",
            "section": "Setting on initial state particles",
            "paragraph_rank": 79,
            "section_rank": 34,
            "ref_spans": [
                {
                    "start": 106,
                    "end": 110,
                    "type": "bibr",
                    "ref_id": "b13",
                    "text": "[16]"
                },
                {
                    "start": 119,
                    "end": 123,
                    "type": "bibr",
                    "ref_id": "b14",
                    "text": "[17]"
                },
                {
                    "start": 147,
                    "end": 151,
                    "type": "bibr",
                    "ref_id": "b15",
                    "text": "[18]"
                }
            ],
            "entity_spans": [
                {
                    "start": 100,
                    "end": 106,
                    "type": "software",
                    "rawForm": "ATLAS",
                    "resp": "service",
                    "id": "software-simple-s15"
                }
            ]
        },
        {
            "text": "Nonetheless, the application scope of the program is still broad. ",
            "section": "Setting on initial state particles",
            "paragraph_rank": 79,
            "section_rank": 34
        },
        {
            "text": "In particular, it applies to the e + e \u2212 colliding experiments where at most tens of particles are produced from the annihilation of a pair of e + e \u2212 in an event. ",
            "section": "Setting on initial state particles",
            "paragraph_rank": 79,
            "section_rank": 34
        },
        {
            "text": "With more user needs coming out in the future, we will further extend and perfect it to make it more powerful and well-rounded.",
            "section": "Setting on initial state particles",
            "paragraph_rank": 79,
            "section_rank": 34
        },
        {
            "text": "particles : 113, 211, \u2212211 or 113, \u2212211, 211 Mother indices of particles : \u22121, 0, 0",
            "paragraph_rank": 80,
            "section_rank": 35
        },
        {
            "text": "Figure 2",
            "section_rank": 36
        },
        {
            "text": "Figure 2: Basic flow chart of the signal identification for decay trees. ",
            "section": "Figure 2",
            "paragraph_rank": 81,
            "section_rank": 36
        },
        {
            "text": "The vectors \"vSigDcyTr\" and \"vNSigDcyTr\" are used to store the signal decay trees specified in the user card file and the numbers of these decay trees found in the input root file, respectively. ",
            "section": "Figure 2",
            "paragraph_rank": 81,
            "section_rank": 36
        },
        {
            "text": "The TBranch \"iSigDcyTr\" in the output root file is used to record the index of the signal decay tree involved in each entry of the input root file.",
            "section": "Figure 2",
            "paragraph_rank": 81,
            "section_rank": 36
        },
        {
            "text": "Figure 3 :",
            "section_rank": 37
        },
        {
            "text": "Figure 3: Basic flow chart of the component analysis over decay trees. ",
            "section": "Figure 3 :",
            "paragraph_rank": 82,
            "section_rank": 37
        },
        {
            "text": "The TBranch \"iDcyTr\" in the output root file is used to record the index of the decay tree involved in each entry of the input root file. ",
            "section": "Figure 3 :",
            "paragraph_rank": 82,
            "section_rank": 37
        },
        {
            "text": "The vectors \"vDcyTr\", \"vIDcyTr\", and \"vNDcyTr\" are used to store the decay trees found in the input root file, their individual indices, and their individual numbers, respectively. ",
            "section": "Figure 3 :",
            "paragraph_rank": 82,
            "section_rank": 37
        },
        {
            "text": "In addition, the unordered map \"uomDcyTr\" is used for the fast matching of decay trees. ",
            "section": "Figure 3 :",
            "paragraph_rank": 82,
            "section_rank": 37
        },
        {
            "text": "Its key and value are the string \"strDcyTr\" and the index \"iDcyTr\", respectively. ",
            "section": "Figure 3 :",
            "paragraph_rank": 82,
            "section_rank": 37
        },
        {
            "text": "Here, the string \"strDcyTr\" is constructed from the vector \"dcyTr\"; there is a one-to-one correspondence between them.",
            "section": "Figure 3 :",
            "paragraph_rank": 82,
            "section_rank": 37
        },
        {
            "text": "#",
            "section_rank": 38
        },
        {
            "text": "The following five items set the input of the program. ",
            "section": "#",
            "paragraph_rank": 83,
            "section_rank": 38
        },
        {
            "text": "% Names of input root files { .",
            "section": "#",
            "paragraph_rank": 83,
            "section_rank": 38
        },
        {
            "text": "./input/jpsi 1.root ../input/jpsi 2.root } % TTree name { evt } % TBranch name of the number of particles (Default: nMCGen) { Nmcps } % TBranch name of the PDG codes of particles (Default: MCGenPDG) { Pid } % TBranch name of the mother indices of particles (Default: MCGenMothIndex) { Midx } # The following item sets the basic functionality of the program. % Component analysis -decay trees { Y } # The following item sets the output of the program. % Common name of output files (Default: Name of the card file) { jpsi ta }",
            "section": "#",
            "paragraph_rank": 83,
            "section_rank": 38
        },
        {
            "text": "Figure 4",
            "section_rank": 39
        },
        {
            "text": "Figure 4: Performance study of the program with the J/\u03c8 sample as well as the \u03c4 + \u03c4 \u2212 , dd, u\u016b, ss, cc, B + B \u2212 , and B 0B0 samples generated at the peak energy of the \u03a5(4S ) resonance. ",
            "section": "Figure 4",
            "paragraph_rank": 84,
            "section_rank": 39
        },
        {
            "text": "The left plot demonstrates the changing trends of the number of elapsed seconds with respect to the number of processed entries. ",
            "section": "Figure 4",
            "paragraph_rank": 84,
            "section_rank": 39
        },
        {
            "text": "The right plot illustrates the relationship between the total number of elapsed seconds over the whole sample and the average number of generated particles in an event. ",
            "section": "Figure 4",
            "paragraph_rank": 84,
            "section_rank": 39
        },
        {
            "text": "In both plots, the dots show the timing data from the standard output of the program, and the lines display the results of fitting linear functions to the data.",
            "section": "Figure 4",
            "paragraph_rank": 84,
            "section_rank": 39
        },
        {
            "text": "Figure 5shows the distribution of X accumulated over the top ten decay trees. ",
            "paragraph_rank": 85,
            "section_rank": 40
        },
        {
            "text": "The figure is drawn with the",
            "paragraph_rank": 85,
            "section_rank": 40
        },
        {
            "text": "%",
            "section_rank": 41
        },
        {
            "text": "Component analysis -decay branches of particles { D*+ Dsp 5 J/psi Jpsi 5 }",
            "section": "%",
            "paragraph_rank": 86,
            "section_rank": 41
        },
        {
            "text": "%",
            "section_rank": 42
        },
        {
            "text": "Signal identification -decay initial-final states { Y(4S) \u2212\u2212> mu+ nu mu 3 pi0 3 pi+ 4 pi\u2212 K+ K\u2212 & 2ndDcyIFStsInTb3 Y(4S) \u2212\u2212> 5 pi0 5 pi+ 5 pi\u2212 K+ K\u2212 & 2ndDcyIFStsInTb3 }",
            "section": "%",
            "paragraph_rank": 87,
            "section_rank": 42
        },
        {
            "text": "the hierarchies of the seven individual branches are 1, 2, 2, 3, 3, 4, and 4, respectively. ",
            "paragraph_rank": 88,
            "section_rank": 43
        },
        {
            "text": "The program provides an item to set the maximum hierarchy. ",
            "paragraph_rank": 88,
            "section_rank": 43
        },
        {
            "text": "Below is an example showing the item with the maximum hierarchy set at one. ",
            "paragraph_rank": 88,
            "section_rank": 43
        },
        {
            "text": "% Maximum hierarchy of heading decay branches to be processed in each event { 1 }",
            "paragraph_rank": 88,
            "section_rank": 43
        },
        {
            "text": "%",
            "section_rank": 44
        },
        {
            "text": "Process charge conjugate objects together (Two options: Y and N. Default: N) { Y } Performing topology analysis with this setting inserts new topology tags in the output root files and adds new counters to topology maps in the output plain text, tex source, and pdf files. ",
            "section": "%",
            "paragraph_rank": 89,
            "section_rank": 44
        },
        {
            "text": "Tables 14 and 15 list and interpret all of the topology tags related to charge conjugation involved in the component analysis and signal identification functionalities, respectively.",
            "section": "%",
            "paragraph_rank": 89,
            "section_rank": 44
        },
        {
            "text": "Table 1 :",
            "section_rank": 45
        },
        {
            "text": "Top ten decay trees and their respective final states.",
            "section": "Table 1 :",
            "paragraph_rank": 90,
            "section_rank": 45
        },
        {
            "text": "Table 2 :",
            "section_rank": 46
        },
        {
            "text": "Decay trees and their respective initial-final states.",
            "section": "Table 2 :",
            "paragraph_rank": 91,
            "section_rank": 46
        },
        {
            "text": "Table 3 :",
            "section_rank": 47
        },
        {
            "text": "Decay initial-final states.",
            "section": "Table 3 :",
            "paragraph_rank": 92,
            "section_rank": 47
        },
        {
            "text": "Table 4 :",
            "section_rank": 48
        },
        {
            "text": "Decay branches of D * + .",
            "section": "Table 4 :",
            "paragraph_rank": 93,
            "section_rank": 48
        },
        {
            "text": "Table 5 :",
            "section_rank": 49
        },
        {
            "text": "Exclusive components of B 0 \u2192 K 0 S + anything.",
            "section": "Table 5 :",
            "paragraph_rank": 94,
            "section_rank": 49
        },
        {
            "text": "Table 7 :",
            "section_rank": 50
        },
        {
            "text": "Signal decay trees and their respective initial-final states.",
            "section": "Table 7 :",
            "paragraph_rank": 95,
            "section_rank": 50
        },
        {
            "text": "Table 8 :",
            "section_rank": 51
        },
        {
            "text": "Signal decay initial-final states.",
            "section": "Table 8 :",
            "paragraph_rank": 96,
            "section_rank": 51
        },
        {
            "text": "Table 9 :",
            "section_rank": 52
        },
        {
            "text": "Signal particles.",
            "section": "Table 9 :",
            "paragraph_rank": 97,
            "section_rank": 52
        },
        {
            "text": "Table 10 :",
            "section_rank": 53
        },
        {
            "text": "Signal decay branches.",
            "section": "Table 10 :",
            "paragraph_rank": 98,
            "section_rank": 53
        },
        {
            "text": "Table 11 :",
            "section_rank": 54
        },
        {
            "text": "Essential topology tags involved in each kind of signal identification.",
            "section": "Table 11 :",
            "paragraph_rank": 99,
            "section_rank": 54
        },
        {
            "text": "Table 12 :",
            "section_rank": 55
        },
        {
            "text": "Decay trees and their respective initial-final states.",
            "section": "Table 12 :",
            "paragraph_rank": 100,
            "section_rank": 55
        },
        {
            "text": "Table 13 :",
            "section_rank": 56
        },
        {
            "text": "Decay trees and their respective initial-final states.",
            "section": "Table 13 :",
            "paragraph_rank": 101,
            "section_rank": 56
        },
        {
            "text": "Table 16 :",
            "section_rank": 57
        },
        {
            "text": "Decay branches of D * + (with the charge conjugation setting).",
            "section": "Table 16 :",
            "paragraph_rank": 102,
            "section_rank": 57
        },
        {
            "text": "Table 17 :",
            "section_rank": 58
        },
        {
            "text": "Decay trees and their respective final states (pp annihilation). ",
            "section": "Table 17 :",
            "paragraph_rank": 103,
            "section_rank": 58
        },
        {
            "text": "pp \u2192 \u03c0 0 \u03c0 0 \u03c00 \u03c0 + \u03c0 + \u03c0 \u2212 \u03c0 \u2212 \u03c0 0 \u03c0 0 \u03c0 0 \u03c0 + \u03c0 + \u03c0 \u2212 \u03c0 \u2212",
            "section": "Table 17 :",
            "paragraph_rank": 103,
            "section_rank": 58
        },
        {
            "text": "% Signal identification -decay trees{ 0 & Upsilon(4S) \u2212\u2212> B0 anti-B0 & \u22121 & 1stDcyTrInTb2 & Y 1 & B0 \u2212\u2212> e+ nu e D*\u2212 gamma & 0 2 & anti-B0 \u2212\u2212> mu\u2212 anti-nu mu D*+ & 0 3 & D*\u2212 \u2212\u2212> pi\u2212 anti-D0 & 1 4 & D*+ \u2212\u2212> pi+ D0 & 2 5 & anti-D0 \u2212\u2212> pi0 pi\u2212 K+ & 3 6 & D0 \u2212\u2212> pi0 pi+ K\u2212 & 4 0 & Upsilon(4S) \u2212\u2212> B0 anti-B0 & \u22121 & 2ndDcyTrInTb2 1 & B0 \u2212\u2212>pi0 pi+ pi\u2212 rho\u2212 D\u2212 & 0 2 & anti-B0 \u2212\u2212> mu\u2212 anti-nu mu D*+ & 0 3 & rho\u2212 \u2212\u2212> pi0 pi\u2212 & 1 4 & D\u2212 \u2212\u2212> pi\u2212 pi\u2212 K+ & 1 5 & D*+ \u2212\u2212> pi+ D0 & 2 6 & D0 \u2212\u2212> K L0 pi+ pi\u2212 & 5 }",
            "section": "Table 17 :",
            "paragraph_rank": 104,
            "section_rank": 58
        },
        {
            "text": "Acknowledgements",
            "section_rank": 60
        },
        {
            "text": "This work was supported by the National Natural Science Foundation of China [grant numbers 11575017, 11661141008, 11761141009, 11875262, 11975076] and the CAS Center for Excellence in Particle Physics (CCEPP). ",
            "section": "Acknowledgements",
            "paragraph_rank": 105,
            "section_rank": 60,
            "entity_spans": [
                {
                    "start": 155,
                    "end": 201,
                    "type": "software",
                    "rawForm": "CAS Center for Excellence in Particle Physics",
                    "resp": "service",
                    "id": "software-simple-s16"
                }
            ]
        },
        {
            "text": "In addition, we would like to thank all of the people who have helped us in the development of the program. ",
            "section": "Acknowledgements",
            "paragraph_rank": 105,
            "section_rank": 60
        },
        {
            "text": "We first thank Prof. Changzheng Yuan, Bo Xin, and Haixuan Chen for their help at the early stage of developing the program. ",
            "section": "Acknowledgements",
            "paragraph_rank": 105,
            "section_rank": 60
        },
        {
            "text": "We are particularly grateful to Prof. Xingtao Huang for his comments on the principles and styles of the program, to Remco de Boer for his suggestions on the tex output and the use of GitHub, and to Xi Chen for his discussions on the core algorithms. ",
            "section": "Acknowledgements",
            "paragraph_rank": 105,
            "section_rank": 60,
            "entity_spans": [
                {
                    "start": 184,
                    "end": 190,
                    "type": "software",
                    "rawForm": "GitHub",
                    "resp": "service",
                    "id": "software-simple-s17"
                }
            ]
        },
        {
            "text": "We are especially indebted to Prof. Xiqing Hao, Longke Li, Xiaoping Qin, Ilya Komarov, Yubo Li, Guanda Gong, Suxian Li, Junhao Yin, Prof. Xiaolong Wang, and Yeqi Chen for their advice in extending and perfecting the program. ",
            "section": "Acknowledgements",
            "paragraph_rank": 105,
            "section_rank": 60
        },
        {
            "text": "Also, we thank Xi'an Xiong, Runqiu Ma, Wencheng Yan, Sen Jia, Lu Cao, Dong Liu, Hongpeng Wang, Jiawei Zhang, Hongrong Qi, Jiajun Liu, Maoqiang Jing, Yi Zhang, Wei Shan, and Yadi Wang for their efforts in helping us test the program.",
            "section": "Acknowledgements",
            "paragraph_rank": 105,
            "section_rank": 60
        }
    ]
}
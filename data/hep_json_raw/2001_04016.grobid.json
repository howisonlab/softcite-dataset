{
    "level": "paragraph",
    "abstract": [
        {
            "text": "Inclusive Monte-Carlo samples are indispensable for signal selection and background suppression in many high energy physics experiments. A clear knowledge of the physics processes involved in the samples, including the types of processes and the number of processes in each type, is a great help to investigating signals and backgrounds. To help analysts obtain the physics process information from the truth information of the samples, we develop a physics process analysis program, TopoAna, with C++, ROOT, and LaTeX. The program implements the functionalities of component analysis and signal identification with many kinds of fine, customizable classification and matching algorithms. It tags physics processes in individual events accurately in the output root files, and exports the physics process information at the sample level clearly to the output plain text, tex source, and pdf files. Independent of specific software frameworks, the program is applicable to many experiments. At present, it has come into use in three e + e \u2212 colliding experiments: the BESIII, Belle, and Belle II experiments. The use of the program in other similar experiments is also prospective.",
            "paragraph_rank": 1,
            "section_rank": 1
        }
    ],
    "body_text": [
        {
            "text": "PROGRAM SUMMARY",
            "section_rank": 2
        },
        {
            "section": "PROGRAM SUMMARY",
            "text": "Program title: TopoAna Licensing provisions: MIT Programming language: C++ Operating system: Linux Nature of problem: A clear knowledge of the physics processes involved in inclusive Monte-Carlo samples is a great help to investigating signals and backgrounds in many high energy physics experiments. However, the raw topology truth information of the samples is counter-intuitive, diverse, and overwhelming, which makes it difficult for analysts to check the physics process information of the samples directly. Solution method: Based on accurate pattern matching, many kinds of fine, customizable classification and",
            "paragraph_rank": 2,
            "section_rank": 2
        },
        {
            "text": "Introduction",
            "section_rank": 3
        },
        {
            "section": "Introduction",
            "text": "One of the most important tasks in the data analysis of high energy physics experiments is to select signals, or in other words, to suppress backgrounds. As for the task, inclusive/generic Monte-Carlo (MC) samples are extremely useful, in that they provide basic, though not perfect, descriptions of the signals and/or backgrounds involved. However, due to the similarities between signals and some backgrounds, it usually takes efforts to establish a set of selection criteria that retain a high signal efficiency and meanwhile keep a low background level. Further optimization of preliminary criteria is often needed in the process. Under the circumstances, a comprehensive understanding of the samples is required. In particular, a clear knowledge of the physics processes, or event types, involved in the samples is quite helpful. To be specific, the physics process information includes the types of processes and the number of processes in each type, involved both in the entire samples and in the individual events. Here, the physics process could be a complete production and decay process involved in an event, or merely a part of it, such as the decay of an intermediate resonance. With the information, one can figure out the main backgrounds (especially the peaking ones), and optimize the selection criteria further by analyzing the differences between the main backgrounds and the signals. Even if it is difficult to further suppress these backgrounds, the knowledge of their types is beneficial to estimate the systematic uncertainties associated with them.",
            "paragraph_rank": 3,
            "section_rank": 3
        },
        {
            "section": "Introduction",
            "text": "The analysis of the physics process information described above is a sort of component analysis. It is complex since it has to classify physics processes actively and finely. Another sort of physics process analysis often required in practice is signal identification, which only aims to search for certain processes of interests. It is relatively simple because its core technique is merely pattern matching. Mostly, signal and background events coexist in inclusive MC samples. It is useful to differentiate them in such cases. The identified signal events can be used to make up a signal sample in the absence of specialized signal samples, or they can be removed to avoid repetition in the presence of specialized signal samples. Occasionally, we have to pick out some decay branches in order to re-weight them according to new theoretical predictions or updated experimental measurements. Signal identification also plays a part in this occasion.",
            "paragraph_rank": 4,
            "section_rank": 3
        },
        {
            "section": "Introduction",
            "text": "Processes in high energy physics can be visualized with topology diagrams. As an example, Fig. 1 shows the topology diagrams of two typical physics processes occurring at e + e \u2212 colliders. From the figure, the hierarchies of the processes and the relationships among the particles are clearly illustrated with the diagrams. Though the complexities of topology diagrams vary with physics processes, there is only one diagram corresponding to each process. For this reason, we refer to the physics process information/analysis mentioned thereinbefore as topology information/analysis hereinafter. The component analysis and signal identification introduced above are exactly the two categories of topology analysis that will be discussed in this paper.",
            "paragraph_rank": 5,
            "section_rank": 3,
            "ref_spans": [
                {
                    "type": "figure",
                    "start": 90,
                    "text": "Fig. 1",
                    "end": 96
                }
            ]
        },
        {
            "section": "Introduction",
            "text": "Since the raw topology truth information of inclusive MC samples is counter-intuitive, diverse, and overwhelming, it is difficult for analysts to check the topology information of the ",
            "paragraph_rank": 6,
            "section_rank": 3
        },
        {
            "section": "Introduction",
            "text": "Figure 1: Topology diagrams of (a) e + e \u2212 \u2192 J/\u03c8, J/\u03c8 \u2192 \u03c1 + \u03c0 \u2212 , \u03c1 + \u2192 \u03c0 + \u03c0 0 , \u03c0 0 \u2192 \u03b3\u03b3 and (b) e + e \u2212 \u2192 \u03a5(4S ), \u03a5(4S ) \u2192 B 0B0 , B 0 \u2192 K 0 S J/\u03c8,B 0 \u2192 \u00b5 \u2212 D * + \u03bd \u00b5 , K 0 S \u2192 \u03c0 + \u03c0 \u2212 , J/\u03c8 \u2192 e + e \u2212 , D * + \u2192 D 0 \u03c0 + , D 0 \u2192 \u03c0 0 \u03c0 + K \u2212 , \u03c0 0 \u2192 \u03b3\u03b3. As if trees grow, the diagrams are plotted from bottom to top. samples directly. To help them do the checks quickly and easily, a topology analysis program called TopoAna is developed with C++, ROOT [1], and LaTeX. Here, C++ is the programming language, ROOT is the C++ based data analysis software universally used in modern high energy physics experiments, and LaTeX is used for generating pdf documents containing the obtained topology information. The program implements the functionalities of component analysis and signal identification based on accurate pattern matching. To meet a variety of practical requirements, many kinds of fine, customizable classification and matching algorithms are implemented in the program. Generally, the program recognizes, categorizes, and counts physics processes in each event in the samples, and tags them in the corresponding entry of the output root (TFile [2]) files. After processing the events, the program exports the obtained topology information at the sample level to the output plain text, tex source, and pdf files.",
            "paragraph_rank": 7,
            "section_rank": 3,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b0",
                    "start": 453,
                    "text": "[1]",
                    "end": 456
                }
            ]
        },
        {
            "section": "Introduction",
            "text": "The program is applicable to inclusive MC samples at any data analysis stage of associated high energy physics experiments. In the overwhelming majority of situations, it is run over the samples which have undergone some selections, in order to examine the signals and backgrounds in the selected samples as well as the effect of the imposed selections. In such situations, the results of topology analysis are usually used together with other quantities for physics analysis. In spite of this, applying the program to the samples without undergoing any selection facilitates us to validate the generators and decay cards that produce the samples and helps novices get familiar with the topology information of the samples.",
            "paragraph_rank": 8,
            "section_rank": 3
        },
        {
            "section": "Introduction",
            "text": "The program has a history of more than ten years. It has already gone through a series of major upgrades. Prior to its development, analysts usually wrote some private codes to match few signals and/or backgrounds for their own studies. The limited functions of these codes do not satisfy the increasing demand for topology analysis. This motivates us to develop a generic, powerful, and easy-to-use program. At first, the program was developed for the BESIII experiment, an experiment in the \u03c4-Charm energy region with abundant research topics under study [3,4]. Later, it was extended substantially for the Belle II experiment, which is primarily dedicated to search for physics beyond the Standard Model in the flavor sector and has already started data taking in the recent three years [5]. Besides, the program has also been tried and used in the Belle experiment, the predecessor of the Belle II experiment, where some physics studies are still ongoing [6]. Not relying on any specific software frameworks, the program now applies to many high energy physics experiments.",
            "paragraph_rank": 9,
            "section_rank": 3,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b1",
                    "start": 557,
                    "text": "[3,",
                    "end": 560
                },
                {
                    "type": "bibr",
                    "ref_id": "b2",
                    "start": 560,
                    "text": "4]",
                    "end": 562
                },
                {
                    "type": "bibr",
                    "ref_id": "b3",
                    "start": 790,
                    "text": "[5]",
                    "end": 793
                },
                {
                    "type": "bibr",
                    "ref_id": "b4",
                    "start": 959,
                    "text": "[6]",
                    "end": 962
                }
            ]
        },
        {
            "section": "Introduction",
            "text": "This paper gives an essential description of TopoAna. It proceeds as follows: Section 2 introduces the basics of the program; Sections 3 and 4 expatiate the two categories of functionalities of the program -component analysis and signal identification, respectively; Section 5 presents some common settings for the executing of the program; Section 6 summarizes the paper. It is worth mentioning here that, aside from the essential description in the paper, a detailed description of the program can be found in the file \"user guide v*.pdf\" under the directory \"share\" of the package.",
            "paragraph_rank": 10,
            "section_rank": 3
        },
        {
            "text": "Basics of the program",
            "section_rank": 4
        },
        {
            "section": "Basics of the program",
            "text": "This section introduces the basics of the program, including the package, input, algorithm, execution, performance, output, and validation of the program. The package implements the program via a C++ class called \"topoana\" and a main function invoking the class. Compiling the package creates the executable file of the program, that is, \"topoana.exe\". To execute the program, we have to first obtain the input data of the program, namely the raw topology truth information of the inclusive MC samples, with some interfaces to the program in the software systems of the corresponding experiments. Normally, the input data contain all the topology information of the samples. With the data, all kinds of the topology analysis presented in the paper can be performed.",
            "paragraph_rank": 11,
            "section_rank": 4
        },
        {
            "section": "Basics of the program",
            "text": "To carry out the topology analysis desired in our work, we have to provide some necessary input, functionality, and output information to the program. The information is required to be filled in the setting items designed and implemented in the program, and the items have to be put in a plain text file named with a suffix \".card\". With the card file, one can execute the program with the command line: \"topoana.exe cardFileName\", where the argument \"cardFile-Name\" is optional and its default value is \"topoana.card\". After the execution of the program, we can examine the results of topology analysis in the output files and use them to analyze other experimental quantities. The results help us gain a better understanding of the signals and backgrounds and are conducive to carrying our work forward. Besides the package, input, execution, and output of the program mentioned above, the algorithm, performance, and validation of the program will also be discussed in this section, because they are also essential aspects of the program. In the next seven subsections, we will present the package, input, algorithm, execution, performance, output, and validation of the program in detail, with each part in one subsection.",
            "paragraph_rank": 12,
            "section_rank": 4
        },
        {
            "text": "Package of the program",
            "section_rank": 5
        },
        {
            "section": "Package of the program",
            "text": "The package consists of six directories -\"include\", \"src\", \"bin\", \"share\", \"examples\", and \"utilities\" -and five files -\"LICENSE\", \"README.md\", \"Configure\", \"Makefile\", and \"Setup\". While the directory \"include\" only includes one header file \"topoana.h\", the directory \"src\" contains sixty source files \"*.cpp\" as well as a script file \"topoana.C\". At present, only one class, namely \"topoana\", is defined in the program for all of its functionalities. The class is declared in \"topoana.h\", implemented in \"*.cpp\" files, and invoked in \"topoana.C\".",
            "paragraph_rank": 13,
            "section_rank": 5
        },
        {
            "section": "Package of the program",
            "text": "The file \"template topoana.card\" under the directory \"share\" saves all the items which are developed for users to specify information for the execution of the program. One can refer to the file when filling in the cards for their own needs. Some plain text files \"pid 3pchrg txtpnm texpnm iccp.dat *\" are also included in the directory \"share\". They store the basic information of the particles used in the program. The suffixes of their names indicate the experiments they apply to. One of them will be copied to \"pid 3pchrg txtpnm texpnm iccp.dat\" when we set up the program. Besides, the directory \"share\" also contains three LaTeX style files \" geometry.sty\", \"ifxetex.sty\", and \"makecell.sty\", which are invoked by the program for generating pdf files. The directory \"examples\" includes plenty of detailed examples. Particularly, all the examples involved in this paper are under its sub-directory \"in the paper\". The directory \"utilities\" contains some useful bash scripts.",
            "paragraph_rank": 14,
            "section_rank": 5
        },
        {
            "section": "Package of the program",
            "text": "The program is released under MIT license [7]. The file \"README.md\" briefly introduces how to install and use the program. To set up the program, one should first set the package path with the command \"./Configure\". Standard outputs of the command are the guidelines for manually adding the absolute path of \"topoana.exe\" to the environment variable \"PATH\", in order to execute it without any path. The second step is executing the command \"make\". This command compiles the header, source, and script files into the executable file \"topoana.exe\" under the directory \"bin\", according to the rules specified in the \"Makefile\". The last step is specifying the experiment name with the command line \"./Setup experimentName\". Currently, the supported experiment names are \"BESIII\", \"Belle\", and \"Belle II\". Besides, \"./Setup Example\" is required for the execution of the examples in the paper.",
            "paragraph_rank": 15,
            "section_rank": 5,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b5",
                    "start": 42,
                    "text": "[7]",
                    "end": 45
                }
            ]
        },
        {
            "text": "Input of the program",
            "section_rank": 6
        },
        {
            "section": "Input of the program",
            "text": "The input of the program is one or more root files including a TTree [2] object which has some TBranch [2] objects containing the raw topology truth information of the inclusive MC samples under study. To be specific, the information in each entry of the TTree object consists of the following three ingredients associated with the particles produced in an event of the samples: the number of particles, PDG [8] codes of particles, and mother indices of particles. Notably, the particles do not include the initial state particles (e + and e \u2212 in e + e \u2212 colliding experiments), which are default and thus omitted. Besides, the indices of particles are integers starting from zero (included) to the number of particles (excluded); they are obvious and hence not taken as an input ingredient for topology analysis. Equation (1) shows an example of the input data. ",
            "paragraph_rank": 16,
            "section_rank": 6,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b6",
                    "start": 408,
                    "text": "[8]",
                    "end": 411
                },
                {
                    "type": "bibr",
                    "ref_id": "b0",
                    "start": 823,
                    "text": "(1)",
                    "end": 826
                }
            ]
        },
        {
            "section": "Input of the program",
            "text": "The complete physics process contained in the data is displayed as follows.",
            "paragraph_rank": 17,
            "section_rank": 6
        },
        {
            "section": "Input of the program",
            "text": "0 e + e \u2212 \u2192 \u03a5(4S ) -1 9",
            "paragraph_rank": 18,
            "section_rank": 6
        },
        {
            "section": "Input of the program",
            "text": "Here, the decay branches in the process are placed into two blocks in order to make full use of the page space. In both blocks, the first, second, and third columns are the indices, symbolic expressions, and mother indices of the decay branches. Notably, all the decay branches of \u03c0 0 \u2192 \u03b3\u03b3 are omitted in Eq. (2) in order to make the process look more concise. Since the topology diagram of such a process looks like a tree, we refer to the complete processes as decay trees. Obviously, the input data do not show the structure automatically. Thus, we need the program to do the topology analysis work. From the first branch in Eq. (2), only one particle \u03a5(4S ) is produced after the e + e \u2212 annihilation. Thus, \u03a5(4S ) can be referred to as the root particle of the decay tree. Similarly, many other resonances with the quantum numbers J PC = 1 \u2212\u2212 , such as J/\u03c8, can be solely produced at other proper energy points. Besides the cases with only one root particle, the program can deal with the cases with multiple root particles. For example, the program can recognize the following raw topology truth information ",
            "paragraph_rank": 19,
            "section_rank": 6
        },
        {
            "section": "Input of the program",
            "text": "as the following process",
            "paragraph_rank": 20,
            "section_rank": 6
        },
        {
            "section": "Input of the program",
            "text": "Here, the particles \u03c0 + \u03c9K \u2212 D * \u2212 D * + s in the first branch arise from hadronization processes, in which quark pairs produced from initial state particles turn into hadrons. The processes with hadronization ignored have a tree structure and thus are easy to resolve. On the other hand, some hadronization processes, particularly those in high energy regions, contain complicated loop structures that are difficult to resolve without sophisticated algorithms. Resolving these intricate hadronization processes is not involved in the program at present.",
            "paragraph_rank": 21,
            "section_rank": 6
        },
        {
            "section": "Input of the program",
            "text": "The input data are recommended to be saved in the TTree object together with other quantities for physics analysis, in order to facilitate the examination of the distributions of these quantities with the topology information. It is easy to get the input of the program within the software framework of high energy physics experiments. To facilitate its use, we have developed the interfaces of the program to the software systems of the BESIII, Belle, and Belle II experiments. Similar interfaces for other experiments can also be implemented with ease. Beyond the scope of the paper, we will not discuss the details of the interfaces here.",
            "paragraph_rank": 22,
            "section_rank": 6
        },
        {
            "text": "Algorithm of the program",
            "section_rank": 7
        },
        {
            "section": "Algorithm of the program",
            "text": "The program resolves physics processes from the input data introduced above. Considering the diversity of the data, the program first sorts them before translating them into physics processes. Here, the diversity means that the data representing a process may have multiple permutations. For example, the data for the decay \u03c1 0 \u2192 \u03c0 + \u03c0 \u2212 have the following two permutations. A decay tree can consist of many decay branches. As a consequence, the diversity issue is complex. To avoid the different permutations of one group of data are identified as different processes, the program first sorts the input data to adjust all the possible permutations to a unique order, according to the PDG codes and electronic charges of the involved particles, and the numbers of their daughter particles in the case of identical particles present in the same decay branch. For example, the two permutations above will be finally sorted into the first permutation (113, 211, \u2212211) in the program. The sorting algorithm is implemented in the source file \"sortPs.cpp\", where some other settings are also involved. One can see the reference file \"sortPs.cpp core\" for the core of the sorting algorithm. After the sorting, the program can get the decay tree from the sorted data into a vector of the type \"vector< list<int> >\" with the function implemented in the source file \"getDcyTr.cpp\".",
            "paragraph_rank": 23,
            "section_rank": 7
        },
        {
            "section": "Algorithm of the program",
            "text": "As mentioned in the previous section, the program has two categories of functionalities: signal identification and component analysis. In this subsection, we introduce the basic algorithms for signal identification and component analysis by taking the cases of decay trees as examples. Figures 2 and 3 show the flow charts of these algorithms in detail. Dozens of lines of code, including some using the ROOT classes TChain, TFile, and TTree [2], are involved in the charts in order to express the algorithms explicitly. The flow chart of the signal identification for decay trees is depicted in Fig. 2. Firstly, the program reads in the signal decay trees specified in the user card file. Then, for each entry of the input root file, the program obtains the decay tree from the sorted input data, matches the decay tree to the signal decay trees, records the index of the matched signal decay tree, and increases the number of the matched signal decay tree. At last, the program outputs the statistics of the signal decay trees.",
            "paragraph_rank": 24,
            "section_rank": 7,
            "ref_spans": [
                {
                    "type": "figure",
                    "ref_id": "fig_2",
                    "start": 286,
                    "text": "Figures 2 and 3",
                    "end": 301
                },
                {
                    "type": "figure",
                    "ref_id": "fig_2",
                    "start": 596,
                    "text": "Fig. 2",
                    "end": 602
                }
            ]
        },
        {
            "section": "Algorithm of the program",
            "text": "The flow chart of the component analysis over decay trees is illustrated in Fig. 3. Despite the similarity in their frameworks, the flow chart has significant differences from that of the signal identification for decay trees in Fig. 2. In the signal identification algorithm, the signal decay trees to be identified are specified beforehand in the user card file. On the contrary, in the component analysis algorithm, the program has to classify decay trees by itself from scratch. In the signal identification algorithm, the decay trees are matched by directly comparing the vectors storing them. Since the number of specified signal decay trees is fixed and usually small, the processing rate of the program is high and usually in constant. However, in the component analysis algorithm, the number of decay tree types found in a sample can be quite large and tends to grow with the number of processed entries. On this occasion, if we still match the decay trees by comparing the vectors storing them, the processing rate of the program will decrease with the increase of the number of processed entries. To improve the processing rate, the unordered map [9], a kind of container template introduced since the C++ 11 standard, is employed for the fast matching of decay trees. Internally, the elements in the unordered maps are organized into buckets depending on their hash values, to allow for fast access to individual elements directly by their key values with a constant average time complexity [9]. This constant feature in average time complexity will be examined in Section 2.5. : Basic flow chart of the signal identification for decay trees. The vectors \"vSigDcyTr\" and \"vNSigDcyTr\" are used to store the signal decay trees specified in the user card file and the numbers of these decay trees found in the input root file, respectively. The TBranch \"iSigDcyTr\" in the output root file is used to record the index of the signal decay tree involved in each entry of the input root file. The TBranch \"iDcyTr\" in the output root file is used to record the index of the decay tree involved in each entry of the input root file. The vectors \"vDcyTr\", \"vIDcyTr\", and \"vNDcyTr\" are used to store the decay trees found in the input root file, their individual indices, and their individual numbers, respectively. In addition, the unordered map \"uomDcyTr\" is used for the fast matching of decay trees. Its key and value are the string \"strDcyTr\" and the index \"iDcyTr\", respectively. Here, the string \"strDcyTr\" is constructed from the vector \"dcyTr\"; there is a one-to-one correspondence between them.",
            "paragraph_rank": 25,
            "section_rank": 7,
            "ref_spans": [
                {
                    "type": "figure",
                    "ref_id": "fig_3",
                    "start": 76,
                    "text": "Fig. 3",
                    "end": 82
                },
                {
                    "type": "figure",
                    "ref_id": "fig_2",
                    "start": 229,
                    "text": "Fig. 2",
                    "end": 235
                }
            ]
        },
        {
            "text": "Execution of the program",
            "section_rank": 8
        },
        {
            "section": "Execution of the program",
            "text": "To execute the program, we have to first configure some necessary setting items in a card file, and then run the program with the command line: \"topoana.exe cardFileName\". This subsection introduces the essential items for the input, basic functionality, and output of the program. More items that can be set in the card file will be described in the following three sections. Sections 3 and 4 expatiate the available items for the functionalities of the program, and Section 5 presents some optional items for the common settings to control the execution of the program.",
            "paragraph_rank": 26,
            "section_rank": 8
        },
        {
            "section": "Execution of the program",
            "text": "An example of the card file containing the essential items is shown as follows. In the card file, \"#\", \"%\", and the pair of \"{\" and \"}\", are used for commenting, prompting, and grouping, respectively. The first five, sixth, and last items are set for the input, basic functionality, and output of the program, respectively.",
            "paragraph_rank": 27,
            "section_rank": 8
        },
        {
            "section": "Execution of the program",
            "text": "The first item sets the names of the input root files. The names ought to be input one per line without tailing characters, such as comma, semicolon, and period. In the names, both the absolute and relative paths are allowed and wildcards \"[]?*\" are supported, just like those in the root file names input to the method Add() of the class TChain [2]. The second item specifies the TTree name. The following three items set the TBranch names of the three ingredients of the raw topology truth information. Of the first five items, the former two are indispensable, whereas the latter three can be removed or left empty if the input values are identical to the default values indicated in their prompts.",
            "paragraph_rank": 28,
            "section_rank": 8
        },
        {
            "section": "Execution of the program",
            "text": "The sixth item sets the basic functionality of the program, namely the component analysis over decay trees. The item can be replaced or co-exist with other functionality items expatiated in Sections 3 and 4. Here, we note that at least one functionality item has to be specified explicitly in the card file, otherwise the program will terminate soon after its start because no topology analysis to be performed is set up.",
            "paragraph_rank": 29,
            "section_rank": 8
        },
        {
            "section": "Execution of the program",
            "text": "The last item specifies the common name of the output files. Though in different formats, the files are denominated with the same name for the sake of uniformity. They will be introduced in detail in the next subsection. This item is also optional, with the name of the card file as its default input value. It is a good practice to first denominate the card file with the desired common name of the output files and then remove this item or leave it empty.",
            "paragraph_rank": 30,
            "section_rank": 8
        },
        {
            "section": "Execution of the program",
            "text": "To provide a complete description, we list and explain all the essential items in the paragraphs above. However, in practical uses, we suggest removing the optional items if the input values are identical to the default ones. In this way, the contents of the card file will become much more concise, making the use of the program easier and quicker. For example, unless otherwise stated, only the following two items are used to set the essential information in Sections 3, 4, and 5. ",
            "paragraph_rank": 31,
            "section_rank": 8
        },
        {
            "text": "Performance of the program",
            "section_rank": 9
        },
        {
            "section": "Performance of the program",
            "text": "Besides the performance of the used computing systems, the processing rate of the program is largely related to the characteristics of the samples, particularly the average number of generated particles in each event. Figure 4 shows the performance study of the program with the J/\u03c8 sample used in the example of this section as well as the \u03c4 + \u03c4 \u2212 , dd, u\u016b, ss, cc, B + B \u2212 , and B 0B0 samples generated at the peak energy of the \u03a5(4S ) resonance. Each of the used samples consists of one hundred thousand events. From the left plot in the figure, for all the samples, the number of elapsed seconds grows linearly with the number of processed entries. This linear pattern is a nice feature. It guarantees the program has a high rate even in the case of processing huge samples. For example, the program can process one hundred thousand J/\u03c8 events within five seconds. Here, we note that the linear pattern is the result of fast searches with unordered maps [9], as we discuss in Section 2.3. On the other hand, the processing rate of the program varies with the processed samples. The right plot in Fig. 4 shows the relationship between the total number of elapsed seconds over the whole sample and the average number of generated particles in an event. Clearly, a linear pattern is also observed in the plot. To be specific, with the average number of generated particles in an event increasing by one, the total number of elapsed seconds over the whole sample increases by about 0.56. : Performance study of the program with the J/\u03c8 sample as well as the \u03c4 + \u03c4 \u2212 , dd, u\u016b, ss, cc, B + B \u2212 , and B 0B0 samples generated at the peak energy of the \u03a5(4S ) resonance. The left plot demonstrates the changing trends of the number of elapsed seconds with respect to the number of processed entries. The right plot illustrates the relationship between the total number of elapsed seconds over the whole sample and the average number of generated particles in an event. In both plots, the dots show the timing data from the standard output of the program, and the lines display the results of fitting linear functions to the data.",
            "paragraph_rank": 32,
            "section_rank": 9,
            "ref_spans": [
                {
                    "type": "figure",
                    "ref_id": "fig_5",
                    "start": 218,
                    "text": "Figure 4",
                    "end": 226
                },
                {
                    "type": "figure",
                    "ref_id": "fig_5",
                    "start": 1100,
                    "text": "Fig. 4",
                    "end": 1106
                }
            ]
        },
        {
            "text": "Output of the program",
            "section_rank": 10
        },
        {
            "section": "Output of the program",
            "text": "The program gains the topology information from input data and saves it to output files. As mentioned in Section 1, the information includes the types of physics processes and the number of processes in each type, involved both in entire samples and in individual events. We refer to the information at the sample level as topology maps. In the topology maps, we assign an integer to each type of physics processes as its index. We term the indices of processes as well as the numbers of processes involved in each type in the individual events as topology tags.",
            "paragraph_rank": 33,
            "section_rank": 10
        },
        {
            "section": "Output of the program",
            "text": "The program outputs topology maps to three different files: one plain text file, one tex source file, and one pdf file, with the same name specified in the card file. For instance, the three files are \"jpsi ta.txt\", \"jpsi ta.tex\", and \"jpsi ta.pdf\" in the example. Although in different formats, the three files have the same information. The pdf file is the easiest to read. It is converted from the tex source file with the command pdflatex. The tex source file is convenient to us if we want to change the style of the pdf file to our taste and when we need to copy and paste (parts of) the topology maps to our slides, papers, and so on. For example, all of the tables displaying topology maps in this paper are taken from associated tex source files. The plain text file has its own advantage, because the topology maps in it can be checked with text processing commands as well as text editors, and can be used on some occasions as input to the functionality items (see Sections 3 and 4 for details) of another card file.",
            "paragraph_rank": 34,
            "section_rank": 10
        },
        {
            "section": "Output of the program",
            "text": "In addition to the three files for topology maps, one or more root files are output to save topology tags. The root files only include one TTree object, which is entirely the same as that in the input root files, except for the topology tags inserted in all of its entries. The number of root files depends on the size of output data. The program switches to one new root file whenever the size of the TTree object in memory exceeds 3 GB. In the case of the size less than 3 GB, only one root file is output. While the sole or first root file has the same name as the three files above, more possible root files are denominated with the suffix \" n\" (n=1, 2, 3, and so on) appended to the name. In the example, the first root file is \"jpsi ta.root\", and more possible root files would be \"jpsi ta 1.root\", \"jpsi ta 2.root\", \"jpsi ta 3.root\", and so on. ",
            "paragraph_rank": 35,
            "section_rank": 10
        },
        {
            "section": "Output of the program",
            "text": "In the example of the previous subsection, the program conducts its basic functionality, namely the component analysis over decay trees. From the 100000 events of the input sample, the program recognizes 17424 decay trees and outputs all of them to the plain text, tex source, and pdf files. Table 1 only shows the top ten decay trees and their respective final states listed in the output pdf file. With the help of the symbolic expressions, the components of the sample are clearly displayed in the table, which brings great convenience to us in examining the signals and backgrounds involved in the sample. In the table, \"rowNo\", \"iDcyTr\", \"nEtr\", and \"nCEtr\" are abbreviations for the row number, index of decay tree, number of entries of decay tree, and number of the cumulative entries from the first to the current decay trees, respectively. The values of \"iDcyTr\" are assigned from small to large in the program but listed according to the values of \"nEtr\" from large to small in the table. This is the reason why they are not in natural order like the values of \"rowNo\". Since J/\u03c8 is the only root particle for the J/\u03c8 sample, the production branch e + e \u2212 \u2192 J/\u03c8 is omitted to save page space. Similar rules also apply to other samples with only one root particle. Considering \u03c0 0 has a very large production rate and approximatively 99% of it decays to \u03b3\u03b3, the program is designed to discard the decay \u03c0 0 \u2192 \u03b3\u03b3 by default at the early phase of processing the input data. As a result, \u03c0 0 \u2192 \u03b3\u03b3 does not show itself in the table. Besides, the superscripts \" f \" and \"F\" in \u03b3 f and \u03b3 F indicate the final state radiation effect. Here, we note that \u03b3 f is translated from a special input PDG code (\u221222 in this example), and \u03b3 F owns a normal PDG code 22 and meanwhile has at least one e \u00b1 , \u00b5 \u00b1 , \u03c0 \u00b1 , K \u00b1 , p, orp sister.",
            "paragraph_rank": 36,
            "section_rank": 10,
            "ref_spans": [
                {
                    "type": "table",
                    "ref_id": "tab_3",
                    "start": 292,
                    "text": "Table 1",
                    "end": 299
                }
            ]
        },
        {
            "section": "Output of the program",
            "text": "In the table, \"iDcyTr\" is the topology tag for decay trees. Thus, it is also saved in the TTree objects of the output root file, together with other quantities for physics analysis. Therefore, it can be used to pick out the entries of specific decay trees and then examine the distributions of the other quantities over the decay trees. In the example, besides the raw topology truth information, only a random variable following the standardized normal distribution, namely X, is stored in the input root files and thus copied by default to the output root file. Though not a genuine variable for physics analysis, X is quite good to illustrate the usage of the topology tag. ",
            "paragraph_rank": 37,
            "section_rank": 10
        },
        {
            "section": "Output of the program",
            "text": "Figure 5: Distribution of X accumulated over the top ten decay trees. In the legend entry \"J/\u03c8 \u2192 \u03c1 + \u03c1 \u2212 \u03c9, ...\", the dots \"...\" represent the secondary decay branches:",
            "paragraph_rank": 38,
            "section_rank": 10
        },
        {
            "section": "Output of the program",
            "text": "examples/in the paper/ex for tb 01/draw X/v2/draw X.C, where, for example, a statement equivalent to chain->Draw(\"X >>h0\", \"iDcyTr==6\") is used to import X over the decay tree J/\u03c8 \u2192 \u00b5 + \u00b5 \u2212 from the output root file to the histogram named h0. With such a figure, we can clearly see the contribution of each decay tree. Particularly, we can get to know whether a decay tree has a peak contribution or a contribution mainly distributed in a different region. Based on these distributions, we can get a better understanding of our signals and backgrounds, and thus optimize event selection criteria by applying new requirements on the displayed quantities.",
            "paragraph_rank": 39,
            "section_rank": 10
        },
        {
            "text": "Validation of the program",
            "section_rank": 11
        },
        {
            "section": "Validation of the program",
            "text": "The decay trees displayed in Table 1 are relatively simple, and we can check their correctness by examining the input data directly. To validate the program generally, we need to do input and output checks, where some arbitrary physics processes are generated as the input of the program. The output has to be consistent with the input; otherwise, there must be some bugs in the program and we have to fix them. A large number of such checks have been performed in the development and application of the program, and some of them can be found under the sub-directory \"examples/validation\" of the package. These checks are divided into two groups: standalone and combined. In the standalone checks, forty exclusive J/\u03c8 and \u03a5(4S ) decays modeled with the EvtGen [10] generator are used to test the functionality of resolving decay trees. In the combined checks, randomly combined samples of these exclusive decays are used for verifying the functionalities of counting and tagging decay trees. The output agrees with the input in all the checks, which indicates the correctness of the program.",
            "paragraph_rank": 40,
            "section_rank": 11,
            "ref_spans": [
                {
                    "type": "table",
                    "ref_id": "tab_3",
                    "start": 29,
                    "text": "Table 1",
                    "end": 36
                },
                {
                    "type": "bibr",
                    "ref_id": "b7",
                    "start": 760,
                    "text": "[10]",
                    "end": 764
                }
            ]
        },
        {
            "text": "Component analysis",
            "section_rank": 12
        },
        {
            "section": "Component analysis",
            "text": "Component analysis is the primary functionality of the program. It is developed mainly for the background analysis involved in our physics studies. We perform it over decay trees in the previous example. Also, it can be carried out as follows: over decay initial-final states; with specified particles to check their decay branches, cascade decay branches, and decay final states; with specified inclusive decay branches to examine their exclusive components; and with specified intermediate-resonance-allowed (IRA) decay branches to investigate their inner structures. In this paper, we only introduce the four representative kinds of component analysis, with each in a subsection (for other kinds of component analysis, please see the user guide attached in the package of the program). For each kind of component analysis, one item is designed and implemented in the program to set related parameters. In each subsection, we take an example to demonstrate the corresponding setting item and show the resulting topology map. For easy exposition, all of the essential topology tags involved in the four representative kinds of component analysis functionalities are presented in another separate subsection, namely the last subsection.",
            "paragraph_rank": 41,
            "section_rank": 12
        },
        {
            "section": "Component analysis",
            "text": "Similar to the case over decay trees, to perform the component analysis over decay initialfinal states, we only need to input a positive option \"Y\" to the corresponding item. Different from the former two kinds, to carry out the latter five kinds of component analysis, we have to explicitly specify one or more desired particles, inclusive decay branches, or IRA decay branches in the associated items. In the following examples, two particles or decay branches are set to illustrate the use of these items, but only the topology map related to one of them is shown to save space in the paper.",
            "paragraph_rank": 42,
            "section_rank": 12
        },
        {
            "section": "Component analysis",
            "text": "In addition to the indispensable parameters, two sorts of common optional parameters can be set in the items. The first sort is designed for all the seven kinds of component analysis to restrict the maximum number of components output to the plain text, tex source, and pdf files. Without the optional parameters, all components will be output. This is fine if the number of components is not massive. In cases of too many (around ten thousand or more) components, it takes a long time for the program to output the components to the plain text and tex source files as well as to get the pdf file from the tex source file. In such cases, it also takes up a large disk space to save these components in the output files. Considering further that the posterior components are generally unimportant and our time and energy to examine them are limited, it is better to set a maximum to the number of output components. To save space in the paper, we set the maximum number to five in the following examples.",
            "paragraph_rank": 43,
            "section_rank": 12
        },
        {
            "section": "Component analysis",
            "text": "The second sort of optional parameters are developed for the latter five kinds of component analysis to assign meaningful aliases to the specified particles, inclusive decay branches, and IRA decay branches. By default, the indices 0, 1, 2, and so on are used to tag the particles and decay branches in the names of the TBranch objects appended in the TTree object of the output root files. This is fine, but it is significative to replace the indices with meaningful aliases, particularly in cases of many specified particles or decay branches.",
            "paragraph_rank": 44,
            "section_rank": 12
        },
        {
            "text": "Decay trees",
            "section_rank": 13
        },
        {
            "section": "Decay trees",
            "text": "Component analysis over decay trees is the basic kind of topology analysis. It is quite useful to study the backgrounds involved in our research works where the signals are the complete decay trees fully reconstructed from final state particles. It has already been widely performed in the BESIII experiment, as illustrated in the previous section with the J/\u03c8 example. This subsection introduces it further with the available optional settings using the \u03a5(4S ) sample. The following example shows the associated item with the maximum number of output components set to five. In the item, a third parameter is also filled and set to \"Y\". With the setting, the decay final states in the output pdf file are put under their respective decay trees, rather than in a column next to that for decay trees. It is recommended to use this optional parameter in cases there are too many (about ten or more) particles in some final states. Here, we note that the symbol \"\u2212\" can be used as a placeholder for the maximum number of output components, if only the third parameter is desired. % Component analysis -decay trees { Y 5 Y } Component analysis over decay trees is one kind of the most time-consuming topology analysis tasks. To check further the efficiency of the program, the progress of running this example, in addition to the example in Section 2.4, is illustrated in the plots of Fig. 4 as well. In these plots, the timing data from this example are marked with the legend entry \"B 0B0 \". Since the decay of the \u03a5(4S ) resonance is more complex than that of the J/\u03c8 resonance, it takes more than twenty seconds for the program to process one hundred thousand events in this example. Nonetheless, the program still has a high processing rate. Table 2 shows the decay trees. In the table, while the first five decay trees are listed exclusively in the main part, the rest decay trees are only summarized inclusively at the bottom row. Here, we note that the events are not densely populated over the first five decay trees because the inclusive \u03a5(4S ) sample used here is not selected beforehand with any requirements. In the symbolic expressions of decay initial-final states, the dashed right arrow ( ) instead of the plain right arrow (\u2192) is used, in order to reflect that the initial states do not necessarily decay to the final states in a direct way. ",
            "paragraph_rank": 45,
            "section_rank": 13,
            "ref_spans": [
                {
                    "type": "figure",
                    "ref_id": "fig_5",
                    "start": 1381,
                    "text": "Fig. 4",
                    "end": 1387
                },
                {
                    "type": "table",
                    "ref_id": "tab_4",
                    "start": 1743,
                    "text": "Table 2",
                    "end": 1750
                }
            ]
        },
        {
            "section": "Decay trees",
            "text": "e + e + \u03bd e \u03bd e \u03c0 0 \u03c0 0 ",
            "paragraph_rank": 46,
            "section_rank": 13
        },
        {
            "text": "Decay initial-final states",
            "section_rank": 14
        },
        {
            "section": "Decay initial-final states",
            "text": "On some occasions, we need to investigate the decay initial-final states of backgrounds for some sophisticated physics analyses. Particularly, it is necessary to differentiate the following two fundamental types of backgrounds: the one with the same initial-final states as the signal, and the other with different initial-final states from the signal. While the latter type of backgrounds needs to be suppressed as much as possible, the former type usually needs to be kept to study more physical effects, for example, the interference effect. Besides, examining the decay initial-final states of backgrounds sheds light on the misjudgment of final state particles at the level of signal candidates. Below is an example demonstrating the related item with the maximum number of output components set to five.",
            "paragraph_rank": 47,
            "section_rank": 14
        },
        {
            "text": "% Component analysis -decay initial-final states",
            "section_rank": 15
        },
        {
            "section": "% Component analysis -decay initial-final states",
            "text": "The decay initial-final states are displayed in Table 3. The layout of the table is similar to that of Table 2, which shows the decay trees.  ",
            "paragraph_rank": 48,
            "section_rank": 15,
            "ref_spans": [
                {
                    "type": "table",
                    "ref_id": "tab_6",
                    "start": 48,
                    "text": "Table 3",
                    "end": 55
                },
                {
                    "type": "table",
                    "ref_id": "tab_4",
                    "start": 103,
                    "text": "Table 2",
                    "end": 110
                }
            ]
        },
        {
            "text": "Decay branches of particles",
            "section_rank": 16
        },
        {
            "section": "Decay branches of particles",
            "text": "The invariant mass constraint is one of the most frequently used event selection requirements in high energy physics experiments. With the requirement applied to certain particle, the main backgrounds (especially the peaking ones) to its signal decay mode are very likely to be its other decay modes. In this case, it is significant to examine the decay branches of the particle. The following example shows the associated item with the two particles D * + and J/\u03c8 set as research objects. In the item, each row holds the information of a specified particle, and the first, second and third columns are the textual expressions, aliases, and maximum numbers of output components, respectively. As we introduce at the beginning part of this section, the aliases and maximum numbers of output components are both optional. Here, we note that the symbol \"\u2212\" can also be used as a placeholder for an unassigned alias, if only the maximum number of output components is desired.  Table 4 shows the decay branches of D * + . From the table, only four decay branches of D * + are found in the input inclusive MC sample. Since there is likely one or more cases of D * + decays in one input entry, \"nCase\" and \"nCCase\", instead of \"nEtr\" and \"nCEtr\", are used in the table in order to accurately indicate what we are counting are the numbers of D * + decays, rather than the numbers of entries involving the D * + decays. It is worth mentioning here that, in addition to decay branches, production branches and mothers of specified particles can also be examined with the program. One can make the program execute the two functionalities by replacing \"decay branches\" in the prompt of the item with \"production branches\" and \"mothers\", respectively.",
            "paragraph_rank": 49,
            "section_rank": 16,
            "ref_spans": [
                {
                    "type": "table",
                    "ref_id": "tab_8",
                    "start": 974,
                    "text": "Table 4",
                    "end": 981
                }
            ]
        },
        {
            "text": "Inclusive decay branches",
            "section_rank": 17
        },
        {
            "section": "Inclusive decay branches",
            "text": "In some physics studies, we take inclusive decay branches as signals. In such cases, it is essential to have a basic knowledge of the exclusive components of these inclusive decay branches. Below is an example demonstrating the related item by investigating the exclusive components of the two inclusive decay branchesB 0 \u2192 D * + + anything and B 0 \u2192 K 0 S + anything. In the item, each row holds the information of an inclusive decay branch, and the first, second, and third columns separated with the symbol \"&\" are the textual expressions, aliases, and maximum numbers of output components, respectively. As we introduce at the beginning part of this section, the aliases and maximum numbers of output components are both optional. Here, we note that the symbol \"\u2212\" can be used as a placeholder for an unassigned alias, if only the maximum number of output components is desired.",
            "paragraph_rank": 50,
            "section_rank": 17
        },
        {
            "text": "% Component analysis -inclusive decay branches",
            "section_rank": 18
        },
        {
            "section": "% Component analysis -inclusive decay branches",
            "text": "The exclusive components of B 0 \u2192 K 0 S + anything are displayed in Table 5. From the table, ten exclusive components of the inclusive decay branch are found in the input sample, and the particles denoted with anything are mainly the traditional charmonium states.  Table 6 lists and interprets all of the essential topology tags involved in the four kinds of component analysis functionalities presented in this section. The topology tag for the component analysis over decay initial-final states is iDcyIFSts. It has a similar interpretation as iDcyTr and Table 6: Essential topology tags involved in each kind of component analysis.",
            "paragraph_rank": 51,
            "section_rank": 18,
            "ref_spans": [
                {
                    "type": "table",
                    "ref_id": "tab_9",
                    "start": 68,
                    "text": "Table 5",
                    "end": 75
                },
                {
                    "type": "table",
                    "start": 266,
                    "text": "Table 6",
                    "end": 273
                },
                {
                    "type": "table",
                    "start": 558,
                    "text": "Table 6",
                    "end": 565
                }
            ]
        },
        {
            "text": "Essential topology tags",
            "section_rank": 19
        },
        {
            "text": "Component type",
            "section_rank": 20
        },
        {
            "section": "Component type",
            "text": "Topology tag Interpretation Decay trees iDcyTr index of decay tree Decay initial-final states iDcyIFSts index of decay initial-final states Decay branches of particles nPDcyBr i number of particle i s (or its decay branches) iDcyBrP i j index of decay branch of the j th particle i Inclusive decay branches nIncDcyBr i number of inclusive decay branch i es iDcyBrIncDcyBr i j index of decay branch of the j th inclusive decay branch i is shown in the third column of Table 3. For the latter five kinds of component analysis, there are two sorts of topology tags. The first sort, such as nPDcyBr i, records the number of instances of the i th specified particle or decay branch found in each event. The second sort, for example, iDcyBrP i j, keeps the associated index of the j th found instance of the i th specified particle or decay branch. The indices and the decays they stand for can be found in Tables 4 and 5. In the topology tags, \"i\" in \" i\" is the default index of the specified particle or decay branch, and it ranges from 0 (included) to the number of specified particles or decay branches (excluded). If the alias of the particle or decay branch is also specified, the index \"i\" will be replaced with the alias. For example, since \"Dsp\" and \"Jpsi\" are set as the aliases of D * + and J/\u03c8 in the component analysis over their decay branches, the specialized topology tags nPDcyBr Dsp and nPDcyBr Jpsi, instead of the default ones nPDcyBr 0 and nPDcyBr 1, are used to store the numbers of D * + and J/\u03c8 found in each event.",
            "paragraph_rank": 52,
            "section_rank": 20,
            "ref_spans": [
                {
                    "type": "table",
                    "ref_id": "tab_6",
                    "start": 467,
                    "text": "Table 3",
                    "end": 474
                },
                {
                    "type": "table",
                    "ref_id": "tab_8",
                    "start": 901,
                    "text": "Tables 4 and 5.",
                    "end": 916
                }
            ]
        },
        {
            "section": "Component type",
            "text": "Besides, \"j\" in \" j\" is the default index of the found instance of certain particle or decay branch in an event, and it ranges from 0 (included) to the sample-level maximum of the number of instances found in each event (excluded). For example, the maximum of the number of D * + found in each event is two for the whole sample, and thus two topology tags iDcyBrP Dsp 0 and iDcyBrP Dsp 1 are employed to store the indices of D * + decay branches. These indices range from 0 (included) to the number of the types of D * + decay branches found in the samples (excluded). In the events with only one D * + , iDcyBrP Dsp 1 is assigned with the default value \u22121; in the events that have no D * + , the default value \u22121 is assigned to both iDcyBrP Dsp 0 and iDcyBrP Dsp 1.",
            "paragraph_rank": 53,
            "section_rank": 20
        },
        {
            "text": "Signal identification",
            "section_rank": 21
        },
        {
            "section": "Signal identification",
            "text": "Signal identification is the other functionality of the program. Though relatively simple, it can help us identify the \"signals\" we desire directly, quickly, and easily. Here, the \"signals\" are not confined to the authentic signals in our research works but can be any physics processes of interests, particularly some important backgrounds we concern. At present, the seven basic kinds of signals that can be identified with the program are as follows: (1) decay trees, (2) decay initialfinal states, (3) particles, (4) (regular) decay branches, (5) cascade decay branches, (6) inclusive decay branches, and (7) IRA decay branches. For each kind of signals, one item is developed to specify related parameters. In this paper, we only introduce the former four kinds of signal identification, with each in a subsection (for the latter three kinds of signal identification, please see the user guide attached in the package of the program). In each subsection, we take an example to demonstrate the related setting item and show the obtained topology map. For easy exposition, all of the essential topology tags involved in the former four kinds of signal identification functionalities are presented in another separate subsection, that is, the last subsection.",
            "paragraph_rank": 54,
            "section_rank": 21
        },
        {
            "section": "Signal identification",
            "text": "Similar to the cases of the latter five kinds of component analysis, one or more signals can be specified in each of the signal identification items, and two signals are set in the following examples to illustrate the use of the items. Besides, meaning aliases can also be optionally assigned to the specified signals so as to better tag them in the names of the TBranch objects appended in the TTree object of the output root files.",
            "paragraph_rank": 55,
            "section_rank": 21
        },
        {
            "text": "Decay trees",
            "section_rank": 22
        },
        {
            "section": "Decay trees",
            "text": "Sometimes, we need to identify certain decay trees. The following example shows the associated item with the first two decay trees listed in Table 2 set as signals. In the item, each row holds a decay branch in the decay trees, and the first, second, and third columns separated with the symbol \"&\" are the indices, textual expressions, and mother indices of the decay branches, respectively. The decay branches with index 0 indicate the beginning of new decay trees, and their mother indices are equal to \u22121, suggesting they have no mother branches because they are the first decay branches of the decay trees. Besides, the name of each decay tree can be optionally filled in the fourth column of its first decay branch. Similar to the third parameter in the item for the component analysis over decay trees (see Section 3.1), a \"Y\" can be optionally filled in the fifth column of the first decay branch of the first decay tree, to adjust the positions of decay final states in the output pdf file. Table 7 shows the resulting topology map. The results are the same as those displayed in the first two rows of Table 2. ",
            "paragraph_rank": 56,
            "section_rank": 22,
            "ref_spans": [
                {
                    "type": "table",
                    "ref_id": "tab_4",
                    "start": 141,
                    "text": "Table 2",
                    "end": 148
                },
                {
                    "type": "table",
                    "ref_id": "tab_10",
                    "start": 1000,
                    "text": "Table 7",
                    "end": 1007
                }
            ]
        },
        {
            "text": "Decay initial-final states",
            "section_rank": 23
        },
        {
            "section": "Decay initial-final states",
            "text": "In some cases, we have an interest in some decay initial-final states. Below is an example demonstrating the related item by taking the first two decay initial-final states listed in Table 3 as signals. Similar to IRA decay branches, decay initial-final states look like inclusive decay branches. Hence, except that only two columns are involved in the item, the format of the input to the item for decay initial-final states is identical to that for the component analysis over inclusive decay branches, which is introduced in Section 3.4. As we can see from the example, the numbers of identical particles are supported to be written in front of their textual names in order to simplify the textual expressions of the final states. The obtained topology map is displayed in Table 8. The results are identical to those shown in the first two rows of Table 3. ",
            "paragraph_rank": 57,
            "section_rank": 23,
            "ref_spans": [
                {
                    "type": "table",
                    "ref_id": "tab_6",
                    "start": 183,
                    "text": "Table 3",
                    "end": 190
                },
                {
                    "type": "table",
                    "ref_id": "tab_11",
                    "start": 776,
                    "text": "Table 8",
                    "end": 783
                },
                {
                    "type": "table",
                    "ref_id": "tab_6",
                    "start": 851,
                    "text": "Table 3",
                    "end": 858
                }
            ]
        },
        {
            "text": "Particles",
            "section_rank": 24
        },
        {
            "section": "Particles",
            "text": "Occasionally, we may want to identify some particles. The following example shows the associated item with the two particles D * + and J/\u03c8 set as signals. Except that only two columns are involved in the item, the format of the input to the item is identical to that for the component analysis over decay branches of particles, which is introduced in Section 3.3.",
            "paragraph_rank": 58,
            "section_rank": 24
        },
        {
            "section": "Particles",
            "text": "% Signal identification -particles { D*+ Dsp J/psi Jpsi } Table 9 shows the resulting topology map. As a cross-check, the number of D * + s in the table equals that in Table 4. ",
            "paragraph_rank": 59,
            "section_rank": 24,
            "ref_spans": [
                {
                    "type": "table",
                    "ref_id": "tab_12",
                    "start": 58,
                    "text": "Table 9",
                    "end": 65
                },
                {
                    "type": "table",
                    "ref_id": "tab_8",
                    "start": 168,
                    "text": "Table 4",
                    "end": 175
                }
            ]
        },
        {
            "text": "Decay branches",
            "section_rank": 25
        },
        {
            "section": "Decay branches",
            "text": "On some occasions, we have to identify certain regular decay branches. Below is an example demonstrating the related item by taking the two decay branchesB 0 \u2192 \u00b5 \u2212\u03bd \u00b5 D * + and B 0 \u2192 K 0 S J/\u03c8 as signals. Since regular decay branches also look like inclusive decay branches, except that only two columns are involved in the item, the format of the input to the item for regular decay branches is identical to that for the component analysis over inclusive decay branches, which is introduced in Section 3.4.",
            "paragraph_rank": 60,
            "section_rank": 25
        },
        {
            "text": "% Signal identification -decay branches",
            "section_rank": 26
        },
        {
            "section": "% Signal identification -decay branches",
            "text": "The obtained topology map is displayed Table 10. For cross-checks, we note that the number of B 0 \u2192 K 0 S J/\u03c8 in the table is equal to that in the first row of Table 5.  Table 11 summarizes and explains all of the essential topology tags involved in the four kinds of signal identification functionalities presented in this section. For signal decay trees and signal decay initial-final states, there are two sorts of topology tags. The first sort of tags, iSigDcyTr and iSigDcyIFSts, record the default indices of the specified signal decay trees and signal decay initial-final states. They have similar interpretations as iDcyTr and iDcyIFSts, and are shown in the third columns of Tables 7 and 8. The second sort of tags, nameSigDcyTr and nameSigDcyIFSts, save the specified aliases of the signal decay trees and signal decay initialfinal states. In cases the aliases are not specified, empty strings will be stored.",
            "paragraph_rank": 61,
            "section_rank": 26,
            "ref_spans": [
                {
                    "type": "table",
                    "ref_id": "tab_3",
                    "start": 39,
                    "text": "Table 10",
                    "end": 47
                },
                {
                    "type": "table",
                    "ref_id": "tab_9",
                    "start": 160,
                    "text": "Table 5",
                    "end": 167
                },
                {
                    "type": "table",
                    "ref_id": "tab_3",
                    "start": 170,
                    "text": "Table 11",
                    "end": 178
                },
                {
                    "type": "table",
                    "ref_id": "tab_10",
                    "start": 684,
                    "text": "Tables 7 and 8",
                    "end": 698
                }
            ]
        },
        {
            "text": "Essential topology tags",
            "section_rank": 27
        },
        {
            "section": "Essential topology tags",
            "text": "For the latter five kinds of signal identification, there is only one sort of topology tags, which records the number of instances of certain specified particle or decay branch found in each event. Similar to the cases in the latter five kinds of component analysis, in the topology tags, \"i\" in \" i\" is the default index of the specified particle or decay branch, and it ranges from 0 (included) to the number of specified particles or decay branches (excluded). If the alias of the particle or decay branch is also specified, the index \"i\" will be replaced with the alias. ",
            "paragraph_rank": 62,
            "section_rank": 27
        },
        {
            "text": "Common settings",
            "section_rank": 28
        },
        {
            "section": "Common settings",
            "text": "From Sections 3 and 4, the optional parameters of the functionality items give us more choices and thus help us do our jobs quicker and better. In addition to these parameters, many optional items are designed and implemented to control the execution of the program in order to meet practical needs. Unlike the optional parameters, which only affect the individual functionalities to which they belong, the optional items have an impact on all of the functionalities, or at least most of the functionalities. The current version of the program contains two dozen common setting items on its input, functionalities, and output. In this paper, we only introduce a part of the items that are crucial to our physics studies (for other items, please see the user guide attached in the package of the program).",
            "paragraph_rank": 63,
            "section_rank": 28
        },
        {
            "text": "Settings on input entries",
            "section_rank": 29
        },
        {
            "section": "Settings on input entries",
            "text": "The program normally processes all of the entries in the input samples, but sometimes only a part of the entries are needed to be (first) processed. Running the program over a big sample usually takes a long time. In such a case, it is a good habit to run the program first over a small part of the sample to check possible exceptions, and then over the whole sample if no exceptions are found or after the found exceptions are handled. Besides, a small number of entries is usually sufficient to do tests in the development of the program. For these reasons, an item is developed to set up the maximum number of entries to be processed. Below is an example showing the item with the maximum number set at two thousand.",
            "paragraph_rank": 64,
            "section_rank": 29
        },
        {
            "section": "Settings on input entries",
            "text": "% Maximum number of entries to be processed { 2000 } On some occasions, especially in the course of optimizing selection criteria, we need to run the program only over entries satisfying certain requirements. For this purpose, an item is developed to select entries. The following example shows the item with X set in the range (\u22121, 1).",
            "paragraph_rank": 65,
            "section_rank": 29
        },
        {
            "section": "Settings on input entries",
            "text": "Notably, only a single-line selection requirement is supported in the item, like the cases in the methods Draw() [2] and GetEntries() [2] of the class TTree. In spite of this, such a requirement is able to express any requirement with the help of the parentheses \"()\" as well as the logical symbols \"&&\", \"||\", and \"!\".",
            "paragraph_rank": 66,
            "section_rank": 29
        },
        {
            "text": "Setting on input decay branches",
            "section_rank": 30
        },
        {
            "section": "Setting on input decay branches",
            "text": "Normally, the program deals with all of the decay branches in every decay tree. However, examining all the branches is not always required in practice. Sometimes, we only concern the first n hierarchies of the branches. Here, the hierarchy reflects the rank of a decay branch in a decay tree. For example, in the decay tree \u03a5 With the setting, the decay branches with hierarchy larger than one will be ignored by the program. For the component analysis over the decay trees of the \u03a5(4S ) sample, only the first hierarchy of \u03a5(4S ) decay branches are analyzed, and the result is shown in Table 12. From the table, not only \u03a5(4S ) \u2192 B 0B0 but also \u03a5(4S ) \u2192 B 0 B 0 and \u03a5(4S ) \u2192B 0B0 are seen because of B 0 -B 0 mixing. Similarly, in the case of the maximum hierarchy set at two, we could get the result of the component analysis over the first two hierarchies of \u03a5(4S ) decay branches, as displayed in Table  13.  ",
            "paragraph_rank": 67,
            "section_rank": 30,
            "ref_spans": [
                {
                    "type": "table",
                    "ref_id": "tab_3",
                    "start": 587,
                    "text": "Table 12",
                    "end": 595
                },
                {
                    "type": "table",
                    "ref_id": "tab_3",
                    "start": 901,
                    "text": "Table  13",
                    "end": 910
                }
            ]
        },
        {
            "text": "Setting on charge conjugation",
            "section_rank": 31
        },
        {
            "section": "Setting on charge conjugation",
            "text": "Charge conjugation is an important concept in high energy physics. By default, charge conjugate objects (particles and decays) are processed separately in the program. However, we need to handle them together in many physics studies because of the sameness between them. One can have the program process them together with the item below set to \"Y\". As an example, we carry out the component analysis over the decay branches of D * + and J/\u03c8 with the charge conjugation setting. The resulting topology map of D * + is displayed in Table  16. Besides the columns in Table 4, two additional columns with the headers \"nCcCase\" and \"nAllCase\" are inserted in the table. Here, \"nCcCase\" represents the number of cases involving the charge conjugate particle (D * \u2212 in this table), and \"nAllCase\" is the sum of \"nCase\" and \"nCcCase\". Table 14: Topology tags related to charge conjugation involved in each kind of component analysis. For the latter five kinds of component analysis, the topology tags in the (1) and (2) groups are only designed for the self-charge-conjugate and non-self-charge-conjugate particles and decay branches, respectively. The acronyms \"cc\" and index cc are short for \"charge conjugate\" and \"charge conjugate index\", respectively. For self-charge-conjugate objects (particles or decays), the charge conjugate indices have the value 0; for non-self-charge-conjugate objects, they have the value 1 or \u22121: while 1 tags the objects presented in the topology maps, \u22121 indicates their charge conjugate objects.",
            "paragraph_rank": 68,
            "section_rank": 31,
            "ref_spans": [
                {
                    "type": "table",
                    "ref_id": "tab_3",
                    "start": 531,
                    "text": "Table  16",
                    "end": 540
                },
                {
                    "type": "table",
                    "ref_id": "tab_8",
                    "start": 565,
                    "text": "Table 4",
                    "end": 572
                },
                {
                    "type": "table",
                    "ref_id": "tab_3",
                    "start": 828,
                    "text": "Table 14",
                    "end": 836
                }
            ]
        },
        {
            "text": "Component type",
            "section_rank": 32
        },
        {
            "section": "Component type",
            "text": "Topology tag Interpretation Decay trees iCcDcyTr index cc of decay tree Decay initial-final states iCcDcyIFSts index cc of decay initial-final states iCcPDcyBr i index cc of particle i (1) iCcDcyBrP i j index cc of decay branch of the j th particle i Decay branches",
            "paragraph_rank": 69,
            "section_rank": 32
        },
        {
            "section": "Component type",
            "text": "(2) nCcPDcyBr i number of cc particle i s (decay branches) of particles",
            "paragraph_rank": 70,
            "section_rank": 32
        },
        {
            "section": "Component type",
            "text": "(2) iDcyBrCcP i j index of decay branch of the j th cc particle i (2) nAllPDcyBr i number of all particle i s (decay branches)",
            "paragraph_rank": 71,
            "section_rank": 32
        },
        {
            "section": "Component type",
            "text": "Inclusive decay branches iCcIncDcyBr i index cc of inclusive decay branch i (1) iCcDcyBrIncDcyBr i j index cc of decay branch of the j th inclusive decay branch i (2) nCcIncDcyBr i number of cc inclusive decay branch i es (2) iDcyBrCcIncDcyBr i j index of decay branch of the j th cc inclusive decay branch i (2) nAllIncDcyBr i number of all inclusive decay branch i es",
            "paragraph_rank": 72,
            "section_rank": 32
        },
        {
            "section": "Component type",
            "text": "In the example, besides the essential topology tags \"nPDcyBr i\" and \"iDcyBrP i j\", the following three groups of topology tags related to charge conjugation are also inserted in the output root files: (1) \"iCcPDcyBr i\" for all specified particles; (2) \"iCcDcyBrP i j\" only for self-chargeconjugate particles, such as J/\u03c8; (3) \"nCcPDcyBr i\", \"iDcyBrCcP i j\", and \"nAllPDcyBr i\" only for non-self-charge-conjugate particles, such as D * + . Here, \"iCcPDcyBr i\" tags whether the i th particle is self-charge-conjugate. For self-charge-conjugate particles, it has the value 0; for non-self-charge-conjugate particles, it has the value 1.",
            "paragraph_rank": 73,
            "section_rank": 32
        },
        {
            "section": "Component type",
            "text": "The topology tag \"iCcDcyBrP i j\" records the charge conjugation property of the decay branch of the j th instance of the i th particle. For self-charge-conjugate decay branches, it has the value 0; for non-self-charge-conjugate decay branches, it has the value 1 or \u22121: while 1 tags the decay branches listed in the topology maps, \u22121 indicates their charge conjugate decay branches. Whereas the equal values of \"iDcyBrP i j\" for each decay branch and its charge conjugate decay branch indicate their sameness, the opposite values of \"iCcDcyBrP i j\" for them reflect their difference.",
            "paragraph_rank": 74,
            "section_rank": 32
        },
        {
            "section": "Component type",
            "text": "The topology tag \"iDcyBrCcP i j\" is designed for the charge conjugate particle of the i th particle (for D * \u2212 in this example). It has a similar meaning as \"iDcyBrP i j\". Particularly, the values of \"iDcyBrP i j\" and \"iDcyBrCcP i j\" tagging charge conjugate decay branches are equal to each other. The topology tag \"nCcPDcyBr i\" stands for the number of instances (or decay branches) of the charge conjugate particle of the i th particle found in each event, and \"nAllPDcyBr i\" is the sum of \"nPDcyBr i\" and \"nCcPDcyBr i\". Table 15: Topology tags related to charge conjugation involved in each kind of signal identification. For the latter five kinds of signal identification, the topology tags in the (*) groups are only designed for the non-self-charge-conjugate particles and decay branches. The acronyms \"cc\" and index cc are short for \"charge conjugate\" and \"charge conjugate index\", respectively. For self-charge-conjugate objects (particles or decays), the charge conjugate indices have the value 0; for non-self-charge-conjugate objects, they have the value 1 or \u22121: while 1 tags the objects presented in the topology maps, \u22121 indicates their charge conjugate objects.",
            "paragraph_rank": 75,
            "section_rank": 32,
            "ref_spans": [
                {
                    "type": "table",
                    "ref_id": "tab_3",
                    "start": 524,
                    "text": "Table 15",
                    "end": 532
                }
            ]
        },
        {
            "text": "Signal type",
            "section_rank": 33
        },
        {
            "section": "Signal type",
            "text": "Topology tag Interpretation Decay trees iCcSigDcyTr index cc of signal decay tree Decay initial-final states iCcSigDcyIFSts index cc of signal decay initial-final states Particles iCcSigP i index cc of signal particle i (*) nCcSigP i number of cc signal particle i s (*) nAllSigP i number of all signal particle i s Decay branches iCcSigDcyBr i index cc of signal decay branch i (*) nCcSigDcyBr i number of cc signal decay branch i es (*) nAllSigDcyBr i number of all signal decay branch i es ",
            "paragraph_rank": 76,
            "section_rank": 33
        },
        {
            "text": "Setting on initial state particles",
            "section_rank": 34
        },
        {
            "section": "Setting on initial state particles",
            "text": "In all of the previous examples, the program is applied to the inclusive MC samples in e + e \u2212 colliding experiments. Besides, the program can also be used in other types of high energy experiments, for example, the PANDA experiment [11], a pp annihilation experiment under construction at Darmstadt, Germany. On these occasions, we have to specify the right initial state particles with the following item to obtain the proper topology maps. % Initial state particles (Default: e\u2212 e+) { anti-p\u2212 p+ } With the setting, the default initial state e + e \u2212 is replaced by pp, as shown in Table 17, which displays the results of a component analysis over decay trees of a small pp annihilation sample. We develop a program, namely TopoAna, with C++, ROOT, and LaTeX for the event type analysis of inclusive MC samples in high energy physics experiments. The program has rich functionalities and aims to solve all kinds of event type analysis tasks. Meanwhile, it is easy to use and has a high processing rate. These features make the program a powerful tool to analyze the backgrounds involved in our research works and to identify the physics processes of interests from the inclusive MC samples.",
            "paragraph_rank": 77,
            "section_rank": 34,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b8",
                    "start": 233,
                    "text": "[11]",
                    "end": 237
                },
                {
                    "type": "table",
                    "ref_id": "tab_3",
                    "start": 584,
                    "text": "Table 17",
                    "end": 592
                }
            ]
        },
        {
            "section": "Setting on initial state particles",
            "text": "Since it does not rely on any specific software frameworks, the program applies to many high energy physics experiments. Up to now, it has been put into use in three experiments at e + e \u2212 colliders: the BESIII, Belle, and Belle II experiments. Besides these experiments, it can also be used in other types of experiments, such as the PANDA experiment, a pp annihilation experiment. Also, the program is applicable to the future e + e \u2212 colliding experiments under research and development, such as the circular electron-positron collider (CEPC) [12,13] experiment in China, the super Charm-\u03c4 factory (SCTF) experiment [14] in Russia, and the super \u03c4-Charm factory (STCF) experiment [15] in China. These experiments offer wide space for the application of the program.",
            "paragraph_rank": 78,
            "section_rank": 34,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b9",
                    "start": 546,
                    "text": "[12,",
                    "end": 550
                },
                {
                    "type": "bibr",
                    "ref_id": "b10",
                    "start": 550,
                    "text": "13]",
                    "end": 553
                },
                {
                    "type": "bibr",
                    "ref_id": "b11",
                    "start": 619,
                    "text": "[14]",
                    "end": 623
                },
                {
                    "type": "bibr",
                    "ref_id": "b12",
                    "start": 683,
                    "text": "[15]",
                    "end": 687
                }
            ]
        },
        {
            "section": "Setting on initial state particles",
            "text": "On the other hand, we note that the application of the program to some other experiments is limited. For example, thousands of particles can be produced from dozens of pp collisions in an event of the ATLAS [16] and CMS [17] experiments at the LHC [18]; in such cases, there is little point in performing the event type analysis of corresponding MC samples. Nonetheless, the application scope of the program is still broad. In particular, it applies to the e + e \u2212 colliding experiments where at most tens of particles are produced from the annihilation of a pair of e + e \u2212 in an event. With more user needs coming out in the future, we will further extend and perfect it to make it more powerful and well-rounded.",
            "paragraph_rank": 79,
            "section_rank": 34,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b13",
                    "start": 207,
                    "text": "[16]",
                    "end": 211
                },
                {
                    "type": "bibr",
                    "ref_id": "b14",
                    "start": 220,
                    "text": "[17]",
                    "end": 224
                },
                {
                    "type": "bibr",
                    "ref_id": "b15",
                    "start": 248,
                    "text": "[18]",
                    "end": 252
                }
            ]
        },
        {
            "text": "particles : 113, 211, \u2212211 or 113, \u2212211, 211 Mother indices of particles : \u22121, 0, 0",
            "paragraph_rank": 80,
            "section_rank": 35
        },
        {
            "text": "Figure 2",
            "section_rank": 36
        },
        {
            "section": "Figure 2",
            "text": "Figure 2: Basic flow chart of the signal identification for decay trees. The vectors \"vSigDcyTr\" and \"vNSigDcyTr\" are used to store the signal decay trees specified in the user card file and the numbers of these decay trees found in the input root file, respectively. The TBranch \"iSigDcyTr\" in the output root file is used to record the index of the signal decay tree involved in each entry of the input root file.",
            "paragraph_rank": 81,
            "section_rank": 36
        },
        {
            "text": "Figure 3 :",
            "section_rank": 37
        },
        {
            "section": "Figure 3 :",
            "text": "Figure 3: Basic flow chart of the component analysis over decay trees. The TBranch \"iDcyTr\" in the output root file is used to record the index of the decay tree involved in each entry of the input root file. The vectors \"vDcyTr\", \"vIDcyTr\", and \"vNDcyTr\" are used to store the decay trees found in the input root file, their individual indices, and their individual numbers, respectively. In addition, the unordered map \"uomDcyTr\" is used for the fast matching of decay trees. Its key and value are the string \"strDcyTr\" and the index \"iDcyTr\", respectively. Here, the string \"strDcyTr\" is constructed from the vector \"dcyTr\"; there is a one-to-one correspondence between them.",
            "paragraph_rank": 82,
            "section_rank": 37
        },
        {
            "text": "#",
            "section_rank": 38
        },
        {
            "section": "#",
            "text": "The following five items set the input of the program. % Names of input root files { ../input/jpsi 1.root ../input/jpsi 2.root } % TTree name { evt } % TBranch name of the number of particles (Default: nMCGen) { Nmcps } % TBranch name of the PDG codes of particles (Default: MCGenPDG) { Pid } % TBranch name of the mother indices of particles (Default: MCGenMothIndex) { Midx } # The following item sets the basic functionality of the program. % Component analysis -decay trees { Y } # The following item sets the output of the program. % Common name of output files (Default: Name of the card file) { jpsi ta }",
            "paragraph_rank": 83,
            "section_rank": 38
        },
        {
            "text": "Figure 4",
            "section_rank": 39
        },
        {
            "section": "Figure 4",
            "text": "Figure 4: Performance study of the program with the J/\u03c8 sample as well as the \u03c4 + \u03c4 \u2212 , dd, u\u016b, ss, cc, B + B \u2212 , and B 0B0 samples generated at the peak energy of the \u03a5(4S ) resonance. The left plot demonstrates the changing trends of the number of elapsed seconds with respect to the number of processed entries. The right plot illustrates the relationship between the total number of elapsed seconds over the whole sample and the average number of generated particles in an event. In both plots, the dots show the timing data from the standard output of the program, and the lines display the results of fitting linear functions to the data.",
            "paragraph_rank": 84,
            "section_rank": 39
        },
        {
            "text": "Figure 5shows the distribution of X accumulated over the top ten decay trees. The figure is drawn with the",
            "paragraph_rank": 85,
            "section_rank": 40
        },
        {
            "text": "%",
            "section_rank": 41
        },
        {
            "section": "%",
            "text": "Component analysis -decay branches of particles { D*+ Dsp 5 J/psi Jpsi 5 }",
            "paragraph_rank": 86,
            "section_rank": 41
        },
        {
            "text": "%",
            "section_rank": 42
        },
        {
            "section": "%",
            "text": "Signal identification -decay initial-final states { Y(4S) \u2212\u2212> mu+ nu mu 3 pi0 3 pi+ 4 pi\u2212 K+ K\u2212 & 2ndDcyIFStsInTb3 Y(4S) \u2212\u2212> 5 pi0 5 pi+ 5 pi\u2212 K+ K\u2212 & 2ndDcyIFStsInTb3 }",
            "paragraph_rank": 87,
            "section_rank": 42
        },
        {
            "text": "the hierarchies of the seven individual branches are 1, 2, 2, 3, 3, 4, and 4, respectively. The program provides an item to set the maximum hierarchy. Below is an example showing the item with the maximum hierarchy set at one. % Maximum hierarchy of heading decay branches to be processed in each event { 1 }",
            "paragraph_rank": 88,
            "section_rank": 43
        },
        {
            "text": "%",
            "section_rank": 44
        },
        {
            "section": "%",
            "text": "Process charge conjugate objects together (Two options: Y and N. Default: N) { Y } Performing topology analysis with this setting inserts new topology tags in the output root files and adds new counters to topology maps in the output plain text, tex source, and pdf files. Tables 14 and 15 list and interpret all of the topology tags related to charge conjugation involved in the component analysis and signal identification functionalities, respectively.",
            "paragraph_rank": 89,
            "section_rank": 44
        },
        {
            "text": "Table 1 :",
            "section_rank": 45
        },
        {
            "section": "Table 1 :",
            "text": "Top ten decay trees and their respective final states.",
            "paragraph_rank": 90,
            "section_rank": 45
        },
        {
            "text": "Table 2 :",
            "section_rank": 46
        },
        {
            "section": "Table 2 :",
            "text": "Decay trees and their respective initial-final states.",
            "paragraph_rank": 91,
            "section_rank": 46
        },
        {
            "text": "Table 3 :",
            "section_rank": 47
        },
        {
            "section": "Table 3 :",
            "text": "Decay initial-final states.",
            "paragraph_rank": 92,
            "section_rank": 47
        },
        {
            "text": "Table 4 :",
            "section_rank": 48
        },
        {
            "section": "Table 4 :",
            "text": "Decay branches of D * + .",
            "paragraph_rank": 93,
            "section_rank": 48
        },
        {
            "text": "Table 5 :",
            "section_rank": 49
        },
        {
            "section": "Table 5 :",
            "text": "Exclusive components of B 0 \u2192 K 0 S + anything.",
            "paragraph_rank": 94,
            "section_rank": 49
        },
        {
            "text": "Table 7 :",
            "section_rank": 50
        },
        {
            "section": "Table 7 :",
            "text": "Signal decay trees and their respective initial-final states.",
            "paragraph_rank": 95,
            "section_rank": 50
        },
        {
            "text": "Table 8 :",
            "section_rank": 51
        },
        {
            "section": "Table 8 :",
            "text": "Signal decay initial-final states.",
            "paragraph_rank": 96,
            "section_rank": 51
        },
        {
            "text": "Table 9 :",
            "section_rank": 52
        },
        {
            "section": "Table 9 :",
            "text": "Signal particles.",
            "paragraph_rank": 97,
            "section_rank": 52
        },
        {
            "text": "Table 10 :",
            "section_rank": 53
        },
        {
            "section": "Table 10 :",
            "text": "Signal decay branches.",
            "paragraph_rank": 98,
            "section_rank": 53
        },
        {
            "text": "Table 11 :",
            "section_rank": 54
        },
        {
            "section": "Table 11 :",
            "text": "Essential topology tags involved in each kind of signal identification.",
            "paragraph_rank": 99,
            "section_rank": 54
        },
        {
            "text": "Table 12 :",
            "section_rank": 55
        },
        {
            "section": "Table 12 :",
            "text": "Decay trees and their respective initial-final states.",
            "paragraph_rank": 100,
            "section_rank": 55
        },
        {
            "text": "Table 13 :",
            "section_rank": 56
        },
        {
            "section": "Table 13 :",
            "text": "Decay trees and their respective initial-final states.",
            "paragraph_rank": 101,
            "section_rank": 56
        },
        {
            "text": "Table 16 :",
            "section_rank": 57
        },
        {
            "section": "Table 16 :",
            "text": "Decay branches of D * + (with the charge conjugation setting).",
            "paragraph_rank": 102,
            "section_rank": 57
        },
        {
            "text": "Table 17 :",
            "section_rank": 58
        },
        {
            "section": "Table 17 :",
            "text": "Decay trees and their respective final states (pp annihilation). pp \u2192 \u03c0 0 \u03c0 0 \u03c00 \u03c0 + \u03c0 + \u03c0 \u2212 \u03c0 \u2212 \u03c0 0 \u03c0 0 \u03c0 0 \u03c0 + \u03c0 + \u03c0 \u2212 \u03c0 \u2212",
            "paragraph_rank": 103,
            "section_rank": 58
        },
        {
            "section": "Table 17 :",
            "text": "% Signal identification -decay trees{ 0 & Upsilon(4S) \u2212\u2212> B0 anti-B0 & \u22121 & 1stDcyTrInTb2 & Y 1 & B0 \u2212\u2212> e+ nu e D*\u2212 gamma & 0 2 & anti-B0 \u2212\u2212> mu\u2212 anti-nu mu D*+ & 0 3 & D*\u2212 \u2212\u2212> pi\u2212 anti-D0 & 1 4 & D*+ \u2212\u2212> pi+ D0 & 2 5 & anti-D0 \u2212\u2212> pi0 pi\u2212 K+ & 3 6 & D0 \u2212\u2212> pi0 pi+ K\u2212 & 4 0 & Upsilon(4S) \u2212\u2212> B0 anti-B0 & \u22121 & 2ndDcyTrInTb2 1 & B0 \u2212\u2212>pi0 pi+ pi\u2212 rho\u2212 D\u2212 & 0 2 & anti-B0 \u2212\u2212> mu\u2212 anti-nu mu D*+ & 0 3 & rho\u2212 \u2212\u2212> pi0 pi\u2212 & 1 4 & D\u2212 \u2212\u2212> pi\u2212 pi\u2212 K+ & 1 5 & D*+ \u2212\u2212> pi+ D0 & 2 6 & D0 \u2212\u2212> K L0 pi+ pi\u2212 & 5 }",
            "paragraph_rank": 104,
            "section_rank": 58
        },
        {
            "text": "Acknowledgements",
            "section_rank": 60
        },
        {
            "section": "Acknowledgements",
            "text": "This work was supported by the National Natural Science Foundation of China [grant numbers 11575017, 11661141008, 11761141009, 11875262, 11975076] and the CAS Center for Excellence in Particle Physics (CCEPP). In addition, we would like to thank all of the people who have helped us in the development of the program. We first thank Prof. Changzheng Yuan, Bo Xin, and Haixuan Chen for their help at the early stage of developing the program. We are particularly grateful to Prof. Xingtao Huang for his comments on the principles and styles of the program, to Remco de Boer for his suggestions on the tex output and the use of GitHub, and to Xi Chen for his discussions on the core algorithms. We are especially indebted to Prof. Xiqing Hao, Longke Li, Xiaoping Qin, Ilya Komarov, Yubo Li, Guanda Gong, Suxian Li, Junhao Yin, Prof. Xiaolong Wang, and Yeqi Chen for their advice in extending and perfecting the program. Also, we thank Xi'an Xiong, Runqiu Ma, Wencheng Yan, Sen Jia, Lu Cao, Dong Liu, Hongpeng Wang, Jiawei Zhang, Hongrong Qi, Jiajun Liu, Maoqiang Jing, Yi Zhang, Wei Shan, and Yadi Wang for their efforts in helping us test the program.",
            "paragraph_rank": 105,
            "section_rank": 60
        }
    ]
}
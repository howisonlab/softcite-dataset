{
    "level": "paragraph",
    "abstract": [
        {
            "text": "FROG [1] is a generic framework dedicated to visualisation of events in high energy experiment. It is suitable to any particular physics experiment or detector design. The code is light (< 3 MB) and fast (browsing time \u223c 20 events per second for a large High Energy Physics experiment) and can run on various operating systems, as its object-oriented structure (C++) relies on the cross-platform OPENGL [2] and GLUT [3] libraries. Moreover, FROG does not require installation of third party libraries for the visualisation. This document describes the features and principles of FROG version 1.106, its working scheme and numerous functionalities such as: 3D and 2D visualisations, graphical user interface, mouse interface, configuration files, production of pictures of various format 1) , integration of personal objects, etc. Finally, several examples of its current applications are presented for illustration. * ) Funded by the \"Fonds de la Recherche Scientifique\" (FNRS) 1) Please, cite the FROG project when publishing FROG based pictures",
            "paragraph_rank": 1,
            "section_rank": 1
        }
    ],
    "body_text": [
        {
            "text": "Introduction",
            "section_rank": 2
        },
        {
            "section": "Introduction",
            "text": "In high energy physics experiments, the possibility to visualise each event is crucial for several reasons. Understanding the event topologies can help in developing better data analysis algorithms. It can also be used as a powerful debugging tool for the simulation and reconstruction experiment softwares.",
            "paragraph_rank": 2,
            "section_rank": 2
        },
        {
            "section": "Introduction",
            "text": "A visualisation tool has to be :",
            "paragraph_rank": 3,
            "section_rank": 2
        },
        {
            "section": "Introduction",
            "text": "\u2022 fluid : draw > 60 frames per second",
            "paragraph_rank": 4,
            "section_rank": 2
        },
        {
            "section": "Introduction",
            "text": "\u2022 fast : scan hundreds of events in few seconds",
            "paragraph_rank": 5,
            "section_rank": 2
        },
        {
            "section": "Introduction",
            "text": "\u2022 light : the entire package should not exceed 10 MB",
            "paragraph_rank": 6,
            "section_rank": 2
        },
        {
            "text": "\u2022 easily upgradable",
            "section_rank": 3
        },
        {
            "section": "\u2022 easily upgradable",
            "text": "\u2022 an intuitive debugging tool",
            "paragraph_rank": 7,
            "section_rank": 3
        },
        {
            "section": "\u2022 easily upgradable",
            "text": "\u2022 able to provide nice illustrations for communications Satisfying simultaneously the above requirements could require heavy usage of all the resources of a computer. In general, these resources are the main limitation of the 3D visualisation. In large experiments such as CMS [4], complex algorithms are used to reconstruct and analyse physics data. Since these algorithms are processor and memory consuming, a fast visualisation tool should be decoupled from simultaneous physics calculations.",
            "paragraph_rank": 8,
            "section_rank": 3,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b2",
                    "start": 277,
                    "text": "[4]",
                    "end": 280
                }
            ]
        },
        {
            "section": "\u2022 easily upgradable",
            "text": "The FROG [1] philosophy is to divide the software into a Producer and a Displayer (Figure 1). It has an impact on several other elements of the software, like the input file format, the operating system portability and the structure of the software. A dedicated FROG File Format (FFF) is needed in order to make the two parts of the code communicate with each other. It has to be highly compact, but the decoding time of the files has also to remain as reduced as possible. Finally, the FFF should also be flexible enough. Its binary encoding ensures its universality with respect to the computer type and to the operating systems. The FFF is described in more detail in Section 2. Figure 1: Factorisation of FROG into the Producer and Displayer components. The Producer is integrated in the experimental software. It extracts, processes and stores the data required by the Displayer, using the FROG File Format for data encapsulation. The Displayer is completely disconnected from the experimental software.",
            "paragraph_rank": 9,
            "section_rank": 3,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b0",
                    "start": 9,
                    "text": "[1]",
                    "end": 12
                },
                {
                    "type": "figure",
                    "start": 82,
                    "text": "(Figure 1",
                    "end": 91
                },
                {
                    "type": "figure",
                    "start": 682,
                    "text": "Figure 1",
                    "end": 690
                }
            ]
        },
        {
            "section": "\u2022 easily upgradable",
            "text": "The Producer (Section 3) is the interface between the physics software of the detector/experiment and the FROG Displayer. This code depends on the respective experiment software but it does not require specific graphical libraries. Its task is to extract and process once for all the data required by the Displayer. For instance, it can convert the position of a hit from local coordinates of the detector to global coordinates. Such computations are in general relatively fast but can slow down the 3D visualisation when repeated many times. The Producer creates two separates files, one containing the processed geometry data (.geom) and one containing the needed events data (.vis). This is the part that the user has to adapt in order to make FROG working for his particular experiment.",
            "paragraph_rank": 10,
            "section_rank": 3
        },
        {
            "section": "\u2022 easily upgradable",
            "text": "The Displayer (Section 4) has the unique function of displaying the content of the .geom and .vis files. It is independent from the experiment software. The Displayer can be distributed and run on different platforms : Windows, Linux and MacOS are currently supported. The only requirement to execute the Displayer is to use some graphic libraries like OPENGL [2] and GLUT [3].",
            "paragraph_rank": 11,
            "section_rank": 3,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b1",
                    "start": 360,
                    "text": "[2]",
                    "end": 363
                },
                {
                    "type": "bibr",
                    "start": 373,
                    "text": "[3]",
                    "end": 376
                }
            ]
        },
        {
            "section": "\u2022 easily upgradable",
            "text": "FROG is completely generic in the sense that it has been designed to be usable for any experiment and also to allow everybody to easily upgrade/add some files in order to use FROG for his particular case. It can then be used eventually for other purposes. The two parts of the code, the Producer and the Displayer are described respectively in Section 3 and 4. Additional features are described in Section 5. A few applications of FROG in specific detector setups/environments are given in Section 6. Future developments of the FROG Package are summarized in Section 7. The two appendices 9A and 9B describe in detail the design and implementation of the software.",
            "paragraph_rank": 12,
            "section_rank": 3
        },
        {
            "text": "FROG File Format",
            "section_rank": 4
        },
        {
            "section": "FROG File Format",
            "text": "The FROG File Format (FFF) will first be described since it is of crucial importance and has a significant impact on the program structure. Since FROG has to be completely generic and has to store needed data in the most compact way, the dedicated file format is based on a binary encoding, where data are organised in chunks. Each chunk contains an Id that specifies the chunk type, a Size that indicates the chunk end, and the Data themselves. The chunk Id is written on 2 Bytes, so 2 16 = 65 536 different chunk types can be handled. The Size is written on 4 Bytes, so the chunk size is limited to 2 32 = 4 GBytes. The Size is defined as :",
            "paragraph_rank": 13,
            "section_rank": 4
        },
        {
            "section": "FROG File Format",
            "text": "The chunks can contain any type of data, which ensures a maximal flexibility to the software. They can be divided into two categories : chunks that contains sub-chunks and those that don't. By similarity with trees, the firsts are called \"branches\" while the others are called \"leaves\". The branches are useful to group together all data of a same experiment/detector/region. See  A file always contains a unique primary chunk that encapsulates, in its Data part, all the other chunks, it's the root of the data tree. It must be of type C PRIMARY=55555. When the primary chunk Size is not equal to the file size, the file is assumed to be corrupted. The experiment data (e.g. the detector geometry or the event signals) are contained in the sub-chunks of this primary chunk. The chunk structure is illustrated in Figure 3. It is often possible to optimize the way data are stored. For instance, if a large number of data of the same type and the same size are stored (e.g. 100 Int32) in a mother chunk. It is clear that it is only needed to define the size and the type once for all the data. This optimized chunk is represented on Figure 4. The best storing method is automatically chosen by FROG in order to reduce the file size. The definition of the chunk structures and the related methods can be found in the files: FROG/FROG Chunk.cpp and FROG/FROG Chunk.h files. ",
            "paragraph_rank": 14,
            "section_rank": 4,
            "ref_spans": [
                {
                    "type": "figure",
                    "ref_id": "fig_2",
                    "start": 813,
                    "text": "Figure 3",
                    "end": 821
                },
                {
                    "type": "figure",
                    "ref_id": "fig_3",
                    "start": 1132,
                    "text": "Figure 4",
                    "end": 1140
                }
            ]
        },
        {
            "text": "FROG Producer",
            "section_rank": 5
        },
        {
            "section": "FROG Producer",
            "text": "The FROG Producer builds the Events and the Geometry of a particular detector and stores them into .vis and .geom files. It is the interface between the detector software 1) and FROG. A FROG Producer already exists for the CMSSW environment. The Producer is the only part of FROG that has to be interfaced to the user needs, and to the experiment software and data format.",
            "paragraph_rank": 15,
            "section_rank": 5
        },
        {
            "section": "FROG Producer",
            "text": "The Producer is in general a part of code (generally C++) that converts the experiment data format to the FFF. Since the Producer does not use specific graphical libraries it can be run in parallel on a computer cluster. The many output .vis files can be merged in a unique file using the FROG merger included in the FROG package. This tool is extremely fast since it just puts the event chunks spread into many files, in the same primary chunk of a unique file.",
            "paragraph_rank": 16,
            "section_rank": 5
        },
        {
            "section": "FROG Producer",
            "text": "The experiment software only needs to include the textscFrog classes definition in order to produce the .vis and .geom. This reduced FROG package, containing only the class definition, takes of the order of \u223c 0.5MB on disk and is freely distributable.",
            "paragraph_rank": 17,
            "section_rank": 5
        },
        {
            "section": "FROG Producer",
            "text": "A Producer example code of a fictitious experiment composed of a particle source beam, eleven tracking layers and a block to stop the beam, can be found in the appendix 9. This example is also available online as a tutorial [5].",
            "paragraph_rank": 18,
            "section_rank": 5,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b3",
                    "start": 224,
                    "text": "[5]",
                    "end": 227
                }
            ]
        },
        {
            "text": "FROG Displayer",
            "section_rank": 6
        },
        {
            "section": "FROG Displayer",
            "text": "This part of the code is completely independent of the detector and does not need to be modified by the FROG users. The code uses extensively the OPENGL library and is programmed such as to keep the rendering of events fast.",
            "paragraph_rank": 19,
            "section_rank": 6
        },
        {
            "section": "FROG Displayer",
            "text": "All the style parameters are loaded from the configuration file (config.txt). The geometry and the current event are displayed in the different 3D/2D views. The display of the first frame can be slow, but then, thanks to the the OPENGL Display Lists, the Displayer can render more than 60 frames per second.",
            "paragraph_rank": 20,
            "section_rank": 6
        },
        {
            "section": "FROG Displayer",
            "text": "Another technique is used to make the display faster for secondary views : after the first draw, an internal screenshot of the view is taken, then, this screenshot is just used to redraw the view. From time to time the screenshot is updated. However the main view does not use this technique.",
            "paragraph_rank": 21,
            "section_rank": 6
        },
        {
            "section": "FROG Displayer",
            "text": "The mouse clicks are handled in order to outline (flashing) and print out information of the mouse selected object.",
            "paragraph_rank": 22,
            "section_rank": 6
        },
        {
            "section": "FROG Displayer",
            "text": "The Figure 5 shows how the simulated events produced in the appendix 9 looks in the FROG Displayer. The FROG configuration file used to get this view is available in the same appendix.  ",
            "paragraph_rank": 23,
            "section_rank": 6,
            "ref_spans": [
                {
                    "type": "figure",
                    "start": 4,
                    "text": "Figure 5",
                    "end": 12
                }
            ]
        },
        {
            "text": "Config File",
            "section_rank": 7
        },
        {
            "section": "Config File",
            "text": "FROG is fully configurable by a set of parameters defined in an ASCII file (FROG/config.txt). This file contains, amongst other things:",
            "paragraph_rank": 24,
            "section_rank": 7
        },
        {
            "section": "Config File",
            "text": "\u2022 the path to the Input .vis file and/or Input .geom file.",
            "paragraph_rank": 25,
            "section_rank": 7
        },
        {
            "section": "Config File",
            "text": "\u2022 the first event to display.",
            "paragraph_rank": 26,
            "section_rank": 7
        },
        {
            "section": "Config File",
            "text": "\u2022 the objects colour, styles and thresholds.",
            "paragraph_rank": 27,
            "section_rank": 7
        },
        {
            "section": "Config File",
            "text": "\u2022 the views to be used.",
            "paragraph_rank": 28,
            "section_rank": 7
        },
        {
            "section": "Config File",
            "text": "The parameters may also be defined in other ASCII files that are included by the main configuration file. Many of these options will be described in the next sections.",
            "paragraph_rank": 29,
            "section_rank": 7
        },
        {
            "text": "Web interface",
            "section_rank": 8
        },
        {
            "section": "Web interface",
            "text": "The event (.vis) and geometry (.geom) files can be downloaded via internet (world wide web) via the http or ftp protocols. This can be steered by setting the URL in the configuration file. For example:",
            "paragraph_rank": 30,
            "section_rank": 8
        },
        {
            "section": "Web interface",
            "text": "\u2022 InputVisFile = {http://projects.hepforge.org/frog/tut/02/SimulatedEvents.vis};",
            "paragraph_rank": 31,
            "section_rank": 8
        },
        {
            "section": "Web interface",
            "text": "\u2022 InputGeom = {http://projects.hepforge.org/frog/tut/02/MyCustomTracker.geom};",
            "paragraph_rank": 32,
            "section_rank": 8
        },
        {
            "section": "Web interface",
            "text": "FROG will download automatically the files using the free libcurl URL transfer library: LIBCURL [6]. Some future planned developments that will extend this functionality are discussed in Section 7.1. It is possible to update the event file periodically in intervals of time defined in the configuration file:",
            "paragraph_rank": 33,
            "section_rank": 8,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b4",
                    "start": 96,
                    "text": "[6]",
                    "end": 99
                }
            ]
        },
        {
            "section": "Web interface",
            "text": "\u2022 updateVisFileTime = 10; // File Update Interval in seconds",
            "paragraph_rank": 34,
            "section_rank": 8
        },
        {
            "section": "Web interface",
            "text": "In this particular case, the event file will be downloaded in a new thread each 10 seconds. When negative values are used the file is not updated. This feature can be useful for visualisation of online events where small .vis files would be produced periodically. These .vis files could then be put on an http or ftp server and be accessible to every users which have FROG installed on their computer. Here, the advantage of using multi-threading is clean: the visualisation of the events is not stopped during the download, and the screen would not be frozen.",
            "paragraph_rank": 35,
            "section_rank": 8
        },
        {
            "text": "Gzipped files",
            "section_rank": 9
        },
        {
            "section": "Gzipped files",
            "text": "Thanks to ZLIB [7], FROG can read gzipped .vis/.geom files automatically, but can also create such files. It is for example very useful to create automatically .vis.gz files instead of .vis files, in particular when the files are distributed to the users via internet. The compression rate is around 50% depending on the event data contained in the .vis files.",
            "paragraph_rank": 36,
            "section_rank": 9,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b5",
                    "start": 15,
                    "text": "[7]",
                    "end": 18
                }
            ]
        },
        {
            "text": "Different Views",
            "section_rank": 10
        },
        {
            "section": "Different Views",
            "text": "A flexible view system is implemented in FROG in order to increase the number of possible views in the same frame. The user can always create the set of views that suits him best only by changing the configuration file. Different types of view are available. The first one is a 3D view of the detector. The view is defined by a set of parameters in the configuration file:",
            "paragraph_rank": 37,
            "section_rank": 10
        },
        {
            "section": "Different Views",
            "text": "\u2022 The viewport: region of the screen that should contain the camera view (X,Y,W,H)",
            "paragraph_rank": 38,
            "section_rank": 10
        },
        {
            "section": "Different Views",
            "text": "\u2022 The Camera Target (X,Y,Z)",
            "paragraph_rank": 39,
            "section_rank": 10
        },
        {
            "section": "Different Views",
            "text": "\u2022 The Camera Position on a sphere centered on the target (R,\u03c6,\u03b7).",
            "paragraph_rank": 40,
            "section_rank": 10
        },
        {
            "section": "Different Views",
            "text": "\u2022 The movement of the camera (animate or not)",
            "paragraph_rank": 41,
            "section_rank": 10
        },
        {
            "section": "Different Views",
            "text": "\u2022 The geometry parts to be displayed in this view",
            "paragraph_rank": 42,
            "section_rank": 10
        },
        {
            "section": "Different Views",
            "text": "The second view type is a 2D orthogonal projection view, which is defined also by a set of parameters. Most of them are common with the 3D view. The 2D views can't be animated. A new parameter is used to define the volume to be projected on the screen. This volume is a cuboid centered on the camera target, with a surface equal to the screen dimension. The volume deep is given by the parameter Slide Depth. So, in the particular case where the 2D camera is aligned with the z axis, the projected objects are contained within an interval in z:",
            "paragraph_rank": 43,
            "section_rank": 10
        },
        {
            "section": "Different Views",
            "text": "[target.z-Slide Depth, target.z+Slide Depth]. A Lego Plot view of specific detectors (e.g. the calorimeter cells) can also be used. The code that defines the view classes is fully tunable in order to add easily new view types [5].",
            "paragraph_rank": 44,
            "section_rank": 10,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b3",
                    "start": 226,
                    "text": "[5]",
                    "end": 229
                }
            ]
        },
        {
            "text": "Tree menu",
            "section_rank": 11
        },
        {
            "section": "Tree menu",
            "text": "A menu accessible with key <F2> is included in the FROG Displayer. This menu is very important and simplifies a lot the use of FROG. The menu is used to specify what content of the .vis/.geom files to display with a user friendly interface in the form of a structural tree which reflects the structure of the .vis/.geom file (see Fig. 2).",
            "paragraph_rank": 45,
            "section_rank": 11,
            "ref_spans": [
                {
                    "type": "figure",
                    "ref_id": "fig_0",
                    "start": 330,
                    "text": "Fig. 2",
                    "end": 336
                }
            ]
        },
        {
            "section": "Tree menu",
            "text": "Branches of the tree represent group of objects (detector or event data). A branch can be opened to see what it contents. The user can also check and modify the display states of the branch (whether or not visible). A second menu is accessible by the key <t>. The <t> menu is defined as a semi-transparent view that is superimposed on top of the other views. It is useful to see in real time the displayed objects changing when states in the menu are modified. This menu has to be defined in the configuration file as well. A screenshot showing this menu is presented in Figure 6. ",
            "paragraph_rank": 46,
            "section_rank": 11,
            "ref_spans": [
                {
                    "type": "figure",
                    "ref_id": "fig_6",
                    "start": 571,
                    "text": "Figure 6",
                    "end": 579
                }
            ]
        },
        {
            "text": "Mouse Interface",
            "section_rank": 12
        },
        {
            "section": "Mouse Interface",
            "text": "In FROG, each object is clickable. When an object is clicked, some information about the objects are printed on the screen. As an example, when clicking on a track the momentum, the transverse momentum, the \u03c7 2 and the number of hits are displayed. Object information to be printed are defined in the class of the selected object. But the selection routines is an important part of the core of FROG. (This is completely transparent for the FROG users, even for the users who want to add new objects).",
            "paragraph_rank": 47,
            "section_rank": 12
        },
        {
            "section": "Mouse Interface",
            "text": "Thanks to the hierarchical structure of the objects it is possible to display the parent of a selected object when clicking on the key <1>, <2>, etc. For example if the selected object is a strip of a tracker module. Hitting <1> will display the module of the strip. Hitting <2> will display the grand-mother of the strip: the tracker. And so on, and so forth. The key <0> and <9> are special. The first just clean up the screen of the parent detectors that have been displayed with <1> to <9>. While the <9> displays the full geometry of the detector. For complex detector this can dramatically slow down the rendering speed.",
            "paragraph_rank": 48,
            "section_rank": 12
        },
        {
            "text": "Online Use",
            "section_rank": 13
        },
        {
            "section": "Online Use",
            "text": "FROG can be used online to have quickly clues on the quality of data taken by the experiment. This is transparent to the user, and usage of FROG online and offline only differs by the fact that in the online case, the Producer and the Displayer are used simultaneously. It is indeed possible to read the .vis file while the Producer is still pushing events into the same file. The temporary .vis file allows many users to look at the latest events without duplication of heavy and slow physics computation.",
            "paragraph_rank": 49,
            "section_rank": 13
        },
        {
            "section": "Online Use",
            "text": "It is possible to configure FROG in order to display always the latest event in the file, in order to see events as soon as they are written into the file. But even in that mode, the user can look at a particular event more deeply just by stopping the event changing (this is done with key <s>).",
            "paragraph_rank": 50,
            "section_rank": 13
        },
        {
            "text": "Production of Pictures",
            "section_rank": 14
        },
        {
            "section": "Production of Pictures",
            "text": "FROG can easily take screenshot of events and detector in order to produce publishable plots. There are two fundamental different ways to take screenshots. The first one, is just to copy all the pixels of the screen and encode them in a particular picture format (e.g. PNG). The second possibility is to store the information to build the picture. This is in general called a vectorial picture. Where objects are stored as a vector of primitives (lines, points, etc). Some well-known picture formats are using this technique (e.g. EPS, PS, PDF, etc.).",
            "paragraph_rank": 51,
            "section_rank": 14
        },
        {
            "section": "Production of Pictures",
            "text": "In FROG, two picture libraries are used (so far) in order to work with the two pictures types. The GL2PS library [8] is used for the vectorial format. It supports a lot of formats: PS, EPS, TEX, PDF, SVG and PGF. When a screenshot is taken (with the <ENTER> key) in that format (defined in the config file), only the active view is saved. Also, the output pictures are in general very heavy because of the high precision of that format. This is the ideal format to use to include FROG pictures in papers.",
            "paragraph_rank": 52,
            "section_rank": 14,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b6",
                    "start": 113,
                    "text": "[8]",
                    "end": 116
                }
            ]
        },
        {
            "section": "Production of Pictures",
            "text": "For the pixelized picture, the PNGLIB [9] and ZLIB [7] libraries are used. This format should be used in all the other contexts because it allows to take screenshots faster and picture file size is lighter. It is also readable by almost every operating system without special softwares or add-ons.",
            "paragraph_rank": 53,
            "section_rank": 14,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b7",
                    "start": 38,
                    "text": "[9]",
                    "end": 41
                },
                {
                    "type": "bibr",
                    "ref_id": "b5",
                    "start": 51,
                    "text": "[7]",
                    "end": 54
                }
            ]
        },
        {
            "text": "Styles",
            "section_rank": 15
        },
        {
            "section": "Styles",
            "text": "Each FROG object contains a FROG Style as data member, which contains all the style options. The styles can be changed directly in the configuration file. Styles of any group of objects can be changed just by using the group EventId or DetId. Below is an example of the text block to setup styles of a RecoTrack Collection with and EventId (23100001): The Color parameter is used to set up the default colour of the track Collection. The colour is defined as a vector of double contained between 0 and 1. With the following syntax {Red, Green, Blue, Alpha}. The Thickness parameter defines the thickness of the line used to draw the track. Marker defines the type of the marker used to display the hits associated to the track.",
            "paragraph_rank": 54,
            "section_rank": 15
        },
        {
            "text": "Examples of Applications",
            "section_rank": 16
        },
        {
            "section": "Examples of Applications",
            "text": "FROG is already used in different experiments and environments, some of them are shown in this section. The two examples described in this section show that FROG can be used in many different applications from the experiment to the simulation environement: GASTOF is a very small detector prototype [10]. The second example, DELPHES is not a detector but a framework for the fast simulation of the response of a generic detector in high energy physics [11].",
            "paragraph_rank": 55,
            "section_rank": 16,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b8",
                    "start": 299,
                    "text": "[10]",
                    "end": 303
                },
                {
                    "type": "bibr",
                    "ref_id": "b9",
                    "start": 452,
                    "text": "[11]",
                    "end": 456
                }
            ]
        },
        {
            "text": "GASTOF: The Ultra-Fast Gas Time-of-Flight Detector",
            "section_rank": 17
        },
        {
            "section": "GASTOF: The Ultra-Fast Gas Time-of-Flight Detector",
            "text": "GASTOF [10][12] detectors are Cherenkov gas detectors that will be located at 420 m from the CMS [4] and ATLAS [13] interaction point (IP), as part of the FP420 project [14] for the LHC [15]. The aim of these detectors is to reduce backgrounds due to accidental coincidence of events detected in the central detectors and in the FP420 detectors on each side of the IP. To achieve that, the event vertex z-coordinate measured by the central detectors is compared to the vertex reconstructed by measuring the time difference of forward proton arrivals to the GASTOF detectors on two sides of the given IP. It requires a very precise measurement of the proton time of flight (\u03b4t \u223c 10-20 ps). Cherenkov photons produced by high energy protons traversing gas medium are reflected by a mirror onto a very fast photomultiplier. In gases, thanks to small refractive index, these photons are emitted at very small angles.",
            "paragraph_rank": 56,
            "section_rank": 17,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b8",
                    "start": 7,
                    "text": "[10]",
                    "end": 11
                },
                {
                    "type": "bibr",
                    "ref_id": "b2",
                    "start": 97,
                    "text": "[4]",
                    "end": 100
                },
                {
                    "type": "bibr",
                    "ref_id": "b11",
                    "start": 111,
                    "text": "[13]",
                    "end": 115
                },
                {
                    "type": "bibr",
                    "ref_id": "b12",
                    "start": 169,
                    "text": "[14]",
                    "end": 173
                },
                {
                    "type": "bibr",
                    "ref_id": "b13",
                    "start": 186,
                    "text": "[15]",
                    "end": 190
                }
            ]
        },
        {
            "text": "Display of the Geometry",
            "section_rank": 18
        },
        {
            "section": "Display of the Geometry",
            "text": "In the simulation, GASTOF is modelled as a finite cuboid volume filled with gas (C 4 F 10 ). Thanks to a toroid mirror placed inside the box, the Cherenkov photons are reflected and focused onto a small photocathode, leaving the box by a \"window\". All the elements are shown on Figure 7, for the 31 cm long GASTOF prototype used for the June 2008 test beam at CERN. ",
            "paragraph_rank": 57,
            "section_rank": 18,
            "ref_spans": [
                {
                    "type": "figure",
                    "ref_id": "fig_8",
                    "start": 278,
                    "text": "Figure 7",
                    "end": 286
                }
            ]
        },
        {
            "text": "Display of the Events",
            "section_rank": 19
        },
        {
            "section": "Display of the Events",
            "text": "The figures below show the simulated GASTOF events comming from the ray-tracing done by the GASTOF simulator [16]. The Figure 8 shows 2D Y-Z projections of six different events while the Figure 9 shows a 3D view of an other event. In both cases, the Cherenkov photons paths (ray) are drawn in yellow.  ",
            "paragraph_rank": 58,
            "section_rank": 19,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b14",
                    "start": 109,
                    "text": "[16]",
                    "end": 113
                },
                {
                    "type": "figure",
                    "ref_id": "fig_9",
                    "start": 119,
                    "text": "Figure 8",
                    "end": 127
                },
                {
                    "type": "figure",
                    "ref_id": "fig_10",
                    "start": 187,
                    "text": "Figure 9",
                    "end": 195
                }
            ]
        },
        {
            "text": "DELPHES: a Framework for the Fast Simulation of a General Purpose Collider Experiment",
            "section_rank": 20
        },
        {
            "section": "DELPHES: a Framework for the Fast Simulation of a General Purpose Collider Experiment",
            "text": "Knowing whether theoretical predictions are visible and measurable in a high energy experiment is always delicate, due to the complexity of the related detectors, their data acquisition chain and their operating software. The DELPHES framework [11] has been introduced for the fast and realistic simulation of a general purpose experiment, like CMS or ATLAS at the LHC. The simulation includes the usual components of such detector as well as possible very forward detectors arranged along the beamline.",
            "paragraph_rank": 59,
            "section_rank": 20,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b9",
                    "start": 244,
                    "text": "[11]",
                    "end": 248
                }
            ]
        },
        {
            "section": "DELPHES: a Framework for the Fast Simulation of a General Purpose Collider Experiment",
            "text": "The framework is interfaced to standard file formats (e.g. Les Houches Event File) and outputs observable analysis data objects, like missing transverse energy and collections of electrons or jets. The simulation of detector response takes into account the detector resolution, by smearing the kinematic properties of the particle. Usual reconstruction algorithms are applied for complex objects, like the missing transverse energy or the jets originating from b quarks or \u03c4 leptons.",
            "paragraph_rank": 60,
            "section_rank": 20
        },
        {
            "section": "DELPHES: a Framework for the Fast Simulation of a General Purpose Collider Experiment",
            "text": "A simplified preselection can also be applied on processed data for trigger emulation. Detection of very forward scattered particles relies on the transport in beamlines. Finally, the visualisation of the collision final states is possible via a dedicated Producer interfacing FROG to DELPHES.",
            "paragraph_rank": 61,
            "section_rank": 20
        },
        {
            "section": "DELPHES: a Framework for the Fast Simulation of a General Purpose Collider Experiment",
            "text": "A fast simulation can be used to obtain realistic observables and fast estimates of signal and background rates for specific channels. Starting from generator-level information, the package provides reconstructed jets, isolated leptons, photons, reconstructed charged tracks, calorimeter towers and the expected transverse missing energy.",
            "paragraph_rank": 62,
            "section_rank": 20
        },
        {
            "section": "DELPHES: a Framework for the Fast Simulation of a General Purpose Collider Experiment",
            "text": "The overall layout of the general purpose detector simulated by DELPHES is shown in Fig. 10 and 11. A central tracking system surrounded by an electromagnetic and a hadron calorimeters. The muon system encloses the detector volume. A forward calorimeter ensure a larger geometric coverage for the measurement of the missing transverse energy. The fast simulation of the detector response takes into account geometrical acceptance of subdetectors and their finite energy resolution. All detectors are assumed to be symmetric with respect to the beam axis. The configuration of the subsystems used in these examples is summarised in Table 1. As an illustration, an associated photoproduction of a W boson and a t quark is shown in Fig. 12. This corresponds to a pp \u2192 W t + p + X process, where the W t couple is induced by an incoming photon emitted by one interacting proton. This leading proton survives from the photon emission and subsequently from the pp interaction, and is present in the final state. The experimental signature is a lack of hadronic activity in one forward hemisphere, where the surviving proton escapes. The t quark decays into a W and a b. Both W bosons decay into leptons (W \u2192 \u00b5\u03bd \u00b5 and W \u2192 \u03c4 \u03bd \u03c4 ). Figure 12: Example of pp(\u03b3p \u2192 W t)pY event. One W boson decays into a \u00b5 \u03bd \u00b5 pair and the second one into a \u03c4 \u03bd \u03c4 pair. The surviving proton leaves a forward hemisphere with no hadronic activity. The isolated muon is shown as the blue vector. The \u03c4 -jet is the cone around the green vector, while the reconstructed missing energy is shown in gray. One jet is visible in one forward region, along the beamline axis, opposite to the direction of the escaping proton.",
            "paragraph_rank": 63,
            "section_rank": 20,
            "ref_spans": [
                {
                    "type": "figure",
                    "start": 84,
                    "text": "Fig. 10 and 11",
                    "end": 98
                },
                {
                    "type": "figure",
                    "ref_id": "fig_0",
                    "start": 729,
                    "text": "Fig. 12",
                    "end": 736
                },
                {
                    "type": "figure",
                    "ref_id": "fig_0",
                    "start": 1224,
                    "text": "Figure 12",
                    "end": 1233
                }
            ]
        },
        {
            "text": "Future Developments",
            "section_rank": 21
        },
        {
            "section": "Future Developments",
            "text": "Since FROG is a very flexible tool that can be considered more as a toolkit than as static software, many perspectives are possible for the evolution of the software. By design, FROG can grow very quickly because all the displayable objects are defined by their own C++ class inheriting from the same base class. Therefore, users can add new needed objects themselves in the software. Moreover, they can also add new types of view.",
            "paragraph_rank": 64,
            "section_rank": 21
        },
        {
            "section": "Future Developments",
            "text": "All the basic tools are ready to be used in a larger scale. Some experiments already started to intensively use the software and numerous feedbacks from this large community of users helped to track bugs and improve the tool.",
            "paragraph_rank": 65,
            "section_rank": 21
        },
        {
            "section": "Future Developments",
            "text": "The short term perspectives consist in the improvement of the tree menu in order to allow the user to change styles, colours, cuts, etc... directly from the menu. By this way, the users will not have to edit any more the FROG configuration file by themselves.",
            "paragraph_rank": 66,
            "section_rank": 21
        },
        {
            "section": "Future Developments",
            "text": "An other improvement which will be implemented is the possibility to filter events contained in the .vis file directly from the Displayer in order to easilly find events satisfying simple criteria.",
            "paragraph_rank": 67,
            "section_rank": 21
        },
        {
            "section": "Future Developments",
            "text": "On the long term perspectives, the possibility to turn FROG into a complete plug-in system will be investigated. If the code implementation is simplified for the user and performances are at least equal, the plugin system will be adopted.",
            "paragraph_rank": 68,
            "section_rank": 21
        },
        {
            "section": "Future Developments",
            "text": "An other long term perspective is to improve the image quality of FROG by improving the 3D perspectives and effects. This can easily be done by adding lighting/shaddowing effects in the 3D scene. This makes in general the feeling of the perspective much better without adding too much complication in the code. This effect has also the advantage to be supported by any OPENGL VGA card.",
            "paragraph_rank": 69,
            "section_rank": 21
        },
        {
            "section": "Future Developments",
            "text": "Of course, users' requests will also be included in the next releases.",
            "paragraph_rank": 70,
            "section_rank": 21
        },
        {
            "text": "FROG Web Service",
            "section_rank": 22
        },
        {
            "section": "FROG Web Service",
            "text": "In collaboration with the Caltech CMS group [18], a pilot project has been started. Its goal is to offer a Web service that allows users to easily produce the FROG visualisation files (.vis, .geom) from CMSSW [17] datasets. This service will offer to users, who do not necessarily have the full CMS software installed locally, a mean to remotely create and then download the Frog files. Since these .vis and .geom files are relatively small (\u223c14Mb/200 events) and the CMSSW processing time to create them is minimal, requests for FROG files from average sized datasets can be processed rapidly and downloaded quickly using standard broadband network connections.",
            "paragraph_rank": 71,
            "section_rank": 22,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b16",
                    "start": 44,
                    "text": "[18]",
                    "end": 48
                },
                {
                    "type": "bibr",
                    "ref_id": "b15",
                    "start": 209,
                    "text": "[17]",
                    "end": 213
                }
            ]
        },
        {
            "section": "FROG Web Service",
            "text": "In the first phase of this project, the FROG Web Service will allow the selection of a CMSSW dataset (containing either simulated or real events) using an interface to DBS, a requested range of runs and/or event numbers, and a choice of which version of CMSSW is to be used to process the data into FROG files. In addition, a browsable and searchable set of previously created FROG files will be provided to the user. In a second phase, the Web Service would be enhanced to allow customized CMSSW configuration files to be uploaded to the server, and to allow the automatic creation of standard FROG projections/displays, which would be stored as graphics files on the server and made available for download via a photo gallery style interface.",
            "paragraph_rank": 72,
            "section_rank": 22
        },
        {
            "text": "Summary",
            "section_rank": 23
        },
        {
            "section": "Summary",
            "text": "The goal of the FROG project was to create a new event display able to quickly display a significative fraction of the event data, in a high energy physics experiment. As a high rendering speed is desirable, the FROG software has been splitted into two parts: the Producer and the Displayer. In addition to the speed enhancement, this structure coupled with a \"home-made\" file format brings many interesting features for free, like the portability of the framework on several operating systems, the independence with respect to the experiment or environment, the possibility to share easily visualisation data, etc. Another important application of FROG is the online experiment data display, as the Producer and the Displayer can work simultaneously.",
            "paragraph_rank": 73,
            "section_rank": 23
        },
        {
            "section": "Summary",
            "text": "In addition of the previous features, FROG is based on an object oriented design. Therefore, it can display almost any imaginable object without any sensitive lost of speed. It can work on almost any recent computer with one of the following Operating Systems: Linux, MacOs or Windows. The size of the full FROG package, including the source code, is less than 4 Mb. It is really suitable for outreach applications since it can be freely distributed and installed in only few clicks. Moreover, latest available data can be automatically downloaded from the internet by the FROG Displayer. One of the main goal of the Displayer was to allow a large number of users to visualise event data in quasi-real time.",
            "paragraph_rank": 74,
            "section_rank": 23
        },
        {
            "section": "Summary",
            "text": "In conclusion, FROG can be used in many applications: it is highly tunable and allows a large number of users to visualise event data. The software is already used by several physicist communities for outreach and detector debugging.",
            "paragraph_rank": 75,
            "section_rank": 23
        },
        {
            "text": "Appendices Appendix A: Base Classes",
            "section_rank": 24
        },
        {
            "section": "Appendices Appendix A: Base Classes",
            "text": "This appendix details some of the main classes used in FROG. The class diagram on Figure 13 shows that all the displayable object classes inherit from FROG Element Base and/or FROG Element Base With DetId. Clues on how these classes work are given for information, but users have not to modify any of the class described here, even if the user want to use the code for its experiment. The class FROG Element Primitive Line is used to give a short description of which methods a class associated to a displayable object has to contain. The hierarchy of the other FROG classes is shown in Figure 14.  ",
            "paragraph_rank": 76,
            "section_rank": 24,
            "ref_spans": [
                {
                    "type": "figure",
                    "ref_id": "fig_2",
                    "start": 82,
                    "text": "Figure 13",
                    "end": 91
                },
                {
                    "type": "figure",
                    "ref_id": "fig_3",
                    "start": 587,
                    "text": "Figure 14",
                    "end": 596
                }
            ]
        },
        {
            "text": "FROG Element Base",
            "section_rank": 25
        },
        {
            "section": "FROG Element Base",
            "text": "All displayable FROG objects are represented by a class that inherit from FROG Element Base. This base class contains several methods used to read/write the data. These classes are used both by the Displayer and the Producer. The three first variables define the chunk: the Id, the size and the data, they are managed directly by the read() and write() methods. The daughters and mother are necessary to navigate in the object's tree. The next variables are used to optimise the display. display list stores a pointer to the object display list [19] 2) . Finally, style contains the aesthetic properties of the object (e.g. colour, thickness, etc.) and the physical cuts",
            "paragraph_rank": 77,
            "section_rank": 25,
            "ref_spans": [
                {
                    "type": "bibr",
                    "start": 545,
                    "text": "[19] 2)",
                    "end": 552
                }
            ]
        },
        {
            "text": "Data",
            "section_rank": 26
        },
        {
            "section": "Data",
            "text": ", etc.) to be applied.",
            "paragraph_rank": 78,
            "section_rank": 26
        },
        {
            "text": "Default Constructor",
            "section_rank": 27
        },
        {
            "section": "Default Constructor",
            "text": "The default constructor of FROG Element Base initialises the data to a null pointer, the type and the size .",
            "paragraph_rank": 79,
            "section_rank": 27
        },
        {
            "text": "Writing method",
            "section_rank": 28
        },
        {
            "section": "Writing method",
            "text": "By design, the only data contained in FROG Element Base object are sub-chunks, it is a branch 3) . So, the write method of this class has only to store the objects contained in the daughters variable into the data data member.",
            "paragraph_rank": 80,
            "section_rank": 28
        },
        {
            "section": "Writing method",
            "text": "2) A display list is a compiled version of the display code stored in the graphic card memory. It is used to improve the rendering speed. 3) if the chunk Id is equal to C PRIMARY the branch is actually the root. The write init() method set up the object and its daughters for storing: it allocates memory, it looks for the optimal storing strategy, etc. The outputs of this function are groups of objects that have to be stored in a same chunk. This output is used by write daughters() which fill the variable data that will be used later to produce the .vis or .geom file.",
            "paragraph_rank": 81,
            "section_rank": 28
        },
        {
            "text": "Reading method",
            "section_rank": 29
        },
        {
            "section": "Reading method",
            "text": "The read() is not really implemented in this class.",
            "paragraph_rank": 82,
            "section_rank": 29
        },
        {
            "text": "Initialisation method",
            "section_rank": 30
        },
        {
            "section": "Initialisation method",
            "text": "FROG Objects is a global structure containing useful variables like the events collection, the geometry, the parameters read from the configuration files, etc. The init(...) method is used to share this pointer to the entire tree and to reset the object styles and cuts to its initial state using configuration parameters.",
            "paragraph_rank": 83,
            "section_rank": 30
        },
        {
            "text": "Display",
            "section_rank": 31
        },
        {
            "section": "Display",
            "text": "The display is done by virtual void display(bool UseDisplayList=true, float * color=NULL). The display lists [19] improve rendering performances, but in some particular cases, they can not be used, this is the reason of the first argument of display. The second argument is a pointer on a float [4] that contains the four components of the colour to use for the object to be drawn. When this argument is NULL, the colour used is taken from the style variable.",
            "paragraph_rank": 84,
            "section_rank": 31,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b17",
                    "start": 109,
                    "text": "[19]",
                    "end": 113
                },
                {
                    "type": "bibr",
                    "ref_id": "b2",
                    "start": 295,
                    "text": "[4]",
                    "end": 298
                }
            ]
        },
        {
            "section": "Display",
            "text": "In the case of a FROG Element Base the display function just call iteratively the display of its daughters and put the result in a display list.",
            "paragraph_rank": 85,
            "section_rank": 31
        },
        {
            "text": "FROG Element Base With DetId",
            "section_rank": 32
        },
        {
            "section": "FROG Element Base With DetId",
            "text": "In large physics experiment, it is convenient to identify each subset of detectors/data; this Id is generally simply an integer. For this reason, the FROG Element Base class has been extended to a class called FROG Element Base With DetId 4) . It is a perfect clone of the base class, except that it contains an extra variable detId of type unsigned int.",
            "paragraph_rank": 86,
            "section_rank": 32,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b2",
                    "start": 239,
                    "text": "4)",
                    "end": 241
                }
            ]
        },
        {
            "text": "Writing method",
            "section_rank": 33
        },
        {
            "section": "Writing method",
            "text": "This new data members is saved by the write() method of the extended class. This extended write() method is completely identical to the write() of the base class except that it contains an extra line that copy the value of detId in data . Similarly, the FROG Element Base With DetId constructor has to be modified to properly initialise the detId , when reading from a file (.geom or .vis).",
            "paragraph_rank": 87,
            "section_rank": 33
        },
        {
            "text": "Reading method",
            "section_rank": 34
        },
        {
            "section": "Reading method",
            "text": "FROG_Element_Base_With_DetId(unsigned short type, FILE * pFile): FROG_Element_Base(type){ size_ = sizeOf(); fread(&detId_ ,sizeof(detId_),1,pFile); }",
            "paragraph_rank": 88,
            "section_rank": 34
        },
        {
            "text": "sizeOf() method",
            "section_rank": 35
        },
        {
            "section": "sizeOf() method",
            "text": "The size of the chunk has changed, so the sizeOf() method has to be updated: The sizeOf method always returns the number of bytes needed to store an object of this class, it is always 6 plus the sum of the sizeof() of all variables stored by this object. This exetend class contains new functions related to detId : a method to get the detId, a method to look for an object with a given detId, etc.",
            "paragraph_rank": 89,
            "section_rank": 35
        },
        {
            "text": "The Reading Procedure",
            "section_rank": 36
        },
        {
            "section": "The Reading Procedure",
            "text": "The reading procedure is handled by a global Read method, which scans iteratively all the chunks contained in a file until the number of bytes read exceed the expected number of bytes to read. A pointer to the mother object is given as an argument of this function, this allows to attach objects created from sub-chunks as daughters of a mother. When a chunk with a known chunk Id is found, a new object of the proper type is created as a daughter of the mother chunk. If this chunk type can contain sub-chunks, the Read method is called recursively using the new object as the mother. The number of bytes to read is computed from the chunk size and from the number of byte already read. The example below shows what is done when a chunk of Id C FEB 5) is found in the file: When the chunks contains data in addition of sub-chunks, the data are read using the object constructor with the file pointer in argument, the number of bytes read by the constructor has to be counted as well. The FROG Element Base With DetId is a perfect example of such an object, the code below describes what is done when a chunk Id of that type is found : The code below is used when an unknown chunk Id is found, which generally indicates a file corruption or incompatibilities. The unknown chunk is simply skipped and a warning message is printed out. The program will anyway display the other objects.",
            "paragraph_rank": 90,
            "section_rank": 36
        },
        {
            "section": "The Reading Procedure",
            "text": "5) C FEB is the Id associated to the FROG Element Base.",
            "paragraph_rank": 91,
            "section_rank": 36
        },
        {
            "section": "The Reading Procedure",
            "text": "default: printf(\"Unknown ChunkID (%i)\\n\",chunk_type); printf(\"Chunk will be skipped\\n\"); printf(\"The program may be not running properly\\n\"); fseek (pFile,chunk_size-chunk_read,SEEK_CUR); chunk_read += chunk_size-chunk_read; break;",
            "paragraph_rank": 92,
            "section_rank": 36
        },
        {
            "text": "FROG Element Primitive Line",
            "section_rank": 37
        },
        {
            "section": "FROG Element Primitive Line",
            "text": "This section details as an example the implementation of a leaf: FROG Element Primitive Line object that is used to draw a line segment in a 3D space. This object is a leaf since it contains data but no sub-chunks. It can be used for the detector geometry design but also for the events representation, for example, a track in a detector without magnetic field is generally displayed as a straight line. The class and variables declaration are done with this code: float variables are the positions of the two points of the line in cartesian XYZ coordinates. The FROG Objects * variable is a container for few global parameters. Since FROG Element Primitive Line inherits from FROG Element Base With DetId, the line object has also a detId that can be used to access the object to define its style for instance. The method isCompactible returns true if the object has a fixed size and the method sizeOf returns the size of an unique chunk. This object has a fixed size of 34 Bytes 6) . The arguments of the FROG Element Base With DetId constructor are the chunk type (C PRIMITIVE LINE) and the detId. The class needs a second constructor that build the object from the input file. 6) SizeOf(EmptyChunk) + 6*SizeOf(float) + SizeOf(DetId) = 6",
            "paragraph_rank": 93,
            "section_rank": 37,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b4",
                    "start": 1181,
                    "text": "6",
                    "end": 1182
                }
            ]
        },
        {
            "section": "FROG Element Primitive Line",
            "text": "FROG_Element_Primitive_Line(FILE * pFile): FROG_Element_Base_With_DetId(C_PRIMITIVE_LINE) { size_ = sizeOf(); fread(&detId_ ,sizeof(detId_) ,1,pFile); fread(&P1X ,sizeof(P1X) ,1,pFile); fread(&P1Y ,sizeof(P1Y) ,1,pFile); fread(&P1Z ,sizeof(P1Z) ,1,pFile); fread(&P2X ,sizeof(P2X) ,1,pFile); fread(&P2Y ,sizeof(P2Y) ,1,pFile); fread(&P2Z ,sizeof(P2Z) ,1,pFile); } Data have to be read/written in the same order. Since the object do not contain daughters, the write() is easyer than FROG Element Base With DetId::write().",
            "paragraph_rank": 94,
            "section_rank": 37
        },
        {
            "section": "FROG Element Primitive Line",
            "text": "virtual void write () { size_ = sizeOf(); data_ = new unsigned char[size_-6]; data_ = FillBuffer( data_, &detId_, sizeof(detId_)); data_ = FillBuffer( data_, &P1X, sizeof(P1X)); data_ = FillBuffer( data_, &P1Y, sizeof(P1Y)); data_ = FillBuffer( data_, &P1Z, sizeof(P1Z)); data_ = FillBuffer( data_, &P2X, sizeof(P2X)); data_ = FillBuffer( data_, &P2Y, sizeof(P2Y)); data_ = FillBuffer( data_, &P2Z, sizeof(P2Z)); data_ = (unsigned char * )((unsigned long)data_ -(size_-6) ); }",
            "paragraph_rank": 95,
            "section_rank": 37
        },
        {
            "section": "FROG Element Primitive Line",
            "text": "The data array is directly initialised by the write function. The object data are iteratively copied in the data variable with the FillBuffer function. The buffer cursor is moved back to the beginning of the buffer.",
            "paragraph_rank": 96,
            "section_rank": 37
        },
        {
            "section": "FROG Element Primitive Line",
            "text": "The init is generally called two times. At the first time, the argument of the function will points to a FROG Objects * , while at the second call the pointer is NULL.",
            "paragraph_rank": 97,
            "section_rank": 37
        },
        {
            "section": "FROG Element Primitive Line",
            "text": "virtual void init(void * frogObjects){ if(frogObjects!=NULL){ frogObjects_ = (FROG_Objects * ) frogObjects; }else if(frogObjects==NULL && frogObjects_ != NULL){ if(mother_!=NULL&&mother_->style_ !=NULL){ style_ = new FROG_Objects_Style(mother_->style_); }else{ style_ = new FROG_Objects_Style(); } frogObjects_->frogCard_->GetColor( style_->color_ ,\"Id_%i_Color\" ,detId_); frogObjects_->frogCard_->GetFloat( &style_->thickness_ ,\"Id_%i_Thickness\" ,detId_); } } If the method's argument is NULL, the init reads the colour and thickness parameters from the configuration file, using frogObjects ->frogCard ->Get... and store them into the style . If no parameters are given, the default colour and thickness value of the mother is used. Finally the display method is almost only OPENGL code:",
            "paragraph_rank": 98,
            "section_rank": 37
        },
        {
            "section": "FROG Element Primitive Line",
            "text": "The ending block that stops the particles and the particle source are attached to the \"OTHER\" branch. They are both represented by a cuboid volume. Finally, a FROG GEOMETRY object is created from the root of the data structure. The FROG GEOMETRY::SAVE() creates and fill the ouput file of name \"MyCustomTracker.geom\".",
            "paragraph_rank": 99,
            "section_rank": 37
        },
        {
            "text": "Fig. 2",
            "section_rank": 38
        },
        {
            "text": "Figure 2 :",
            "section_rank": 39
        },
        {
            "section": "Figure 2 :",
            "text": "Figure 2: A schematic view of the tree structure of a FFF.",
            "paragraph_rank": 101,
            "section_rank": 39
        },
        {
            "text": "Figure 3 :",
            "section_rank": 40
        },
        {
            "section": "Figure 3 :",
            "text": "Figure 3: Example of data file. The primary chunk contains two sub-chunks storing an integer and a float.",
            "paragraph_rank": 102,
            "section_rank": 40
        },
        {
            "text": "Figure 4 :",
            "section_rank": 41
        },
        {
            "section": "Figure 4 :",
            "text": "Figure 4: Example of the chunk structure if the file contains 100 Int32.",
            "paragraph_rank": 103,
            "section_rank": 41
        },
        {
            "text": "Figure 5 : 1 )",
            "section_rank": 42
        },
        {
            "section": "Figure 5 : 1 )",
            "text": "Figure 5: Three different FROG Display views: big 3D view (top), 2D longitudinal (bottom right), transversal view (bottom left). The different geometry parts are well visible : Particle Gun (grey), the Ending Block (grey) and the eleven tracking layers (blue). The particle track is shown in red.1)Two examples of detector software are CMSSW in the CMS experiment and Athena in the ATLAS experiment.",
            "paragraph_rank": 104,
            "section_rank": 42
        },
        {
            "text": "Features",
            "section_rank": 43
        },
        {
            "text": "Figure 6 :",
            "section_rank": 44
        },
        {
            "section": "Figure 6 :",
            "text": "Figure 6: Similar to Fig. 5 except that the <t> menu is opened. Both the event and geometry structures are visible. All the lines are green since all the objects are displayed. Hits position and charge are listed as well as the track properties.",
            "paragraph_rank": 106,
            "section_rank": 44
        },
        {
            "text": "Figure 7 :",
            "section_rank": 45
        },
        {
            "section": "Figure 7 :",
            "text": "Figure 7: A 3D View of the full GASTOF geometry (in wireframe). The gaseous Cherenkov detector is represented by the green box. Inside the box, there is a toroid mirror (grey). A window (red) is present in the box to allow photons focused by the mirror to reach the GASTOF photomultiplier. The sensitive zone of the PMT photocathode is represented by the blue circle. Only the sensitive zone of the photomultiplier is drawn since the other parts do not affect the photon detection.",
            "paragraph_rank": 107,
            "section_rank": 45
        },
        {
            "text": "Figure 8 :",
            "section_rank": 46
        },
        {
            "section": "Figure 8 :",
            "text": "Figure 8: 2D views of six different GASTOF events: The proton trajectory (going from right to left in that view) is represented by the blue line. While photon trajectories (ray) are shown in yellow. The Cherenkov photon production is well visible along the proton path. The majority of produced photons are reflected by the curved mirror and focused on the photo-cathode. Note that some photons are not reflected on the mirror and than some others miss the PMT.",
            "paragraph_rank": 108,
            "section_rank": 46
        },
        {
            "text": "Figure 9 :",
            "section_rank": 47
        },
        {
            "section": "Figure 9 :",
            "text": "Figure 9: 3D view zoomed on the GASTOF mirror. Legend and colour codes have already been described inFigure 8.",
            "paragraph_rank": 109,
            "section_rank": 47
        },
        {
            "text": "Figure 10 : 4 Table 1 : 11 Figure 11 :",
            "section_rank": 48
        },
        {
            "section": "Figure 10 : 4 Table 1 : 11 Figure 11 :",
            "text": "Figure 10: Left: Layout of the generic detector geometry assumed in DELPHES. The innermost layer, close to the interaction point, is a central tracking system (pink). It is surrounded by a central calorimeter volume (green) with both electromagnetic and hadronic sections. The outer layer of the central system (red) consist of a muon system. In addition, two end-cap calorimeters (blue) extend the pseudorapidity coverage of the central detector. The actual detector granularity and extension is defined in the user-configuration card. The detector is assumed to be strictly symmetric around the beam axis (black line). Additional forward detectors are not depicted. Right: Profile of the layout assumed in DELPHES. The extension of the various subdetectors, as defined in Tab. 1, are clearly visible.",
            "paragraph_rank": 110,
            "section_rank": 48
        },
        {
            "text": "Figure 13 :",
            "section_rank": 49
        },
        {
            "section": "Figure 13 :",
            "text": "Figure 13: The FROG class hierarchy of the displayable objects. All the displayable object classes inherit from FROG Element Base. The three classes on the extreme left of this diagram are generally used as objects containers (branch).",
            "paragraph_rank": 111,
            "section_rank": 49
        },
        {
            "text": "Figure 14 :",
            "section_rank": 50
        },
        {
            "section": "Figure 14 :",
            "text": "Figure 14: The FROG class hierarchy of the other objects like the different views.",
            "paragraph_rank": 112,
            "section_rank": 50
        },
        {
            "text": "/",
            "section_rank": 51
        },
        {
            "section": "/",
            "text": "/ Fill data_ and size_ with data virtual void write(){ std::vector< std::pair<unsigned int, unsigned int > > * blockOfDaughters; blockOfDaughters = write_init(); if(blockOfDaughters==NULL)return; write_daughters(blockOfDaughters); }",
            "paragraph_rank": 113,
            "section_rank": 51
        },
        {
            "text": "/",
            "section_rank": 52
        },
        {
            "section": "/",
            "text": "/ Fill data_ and size_ with data virtual void write(){ std::vector< std::pair<unsigned int, unsigned int > > * blockOfDaughters; blockOfDaughters = write_init(); if(blockOfDaughters==NULL)return; data_ = FillBuffer(data_, &detId_, sizeof(int)); // write the detId_ write_daughters(blockOfDaughters); }",
            "paragraph_rank": 114,
            "section_rank": 52
        },
        {
            "text": "static unsigned int sizeOf(){ return 6 + sizeof(unsigned int); }",
            "paragraph_rank": 115,
            "section_rank": 53
        },
        {
            "text": "case C_FEB: TemporyElement = new FROG_Element_Base(chunk_type); mother->addDaughter(TemporyElement); chunk_read += Read(pFile,TemporyElement,chunk_size-chunk_read); break; }",
            "paragraph_rank": 116,
            "section_rank": 54
        },
        {
            "text": "FROG_Element_Base_With_DetId(chunk_type,pFile); mother->addDaughter(TemporyElement); chunk_read += FROG_Element_Base_With_DetId::sizeOf()-6; chunk_read += Read(pFile,TemporyElement,chunk_size-chunk_read); break;",
            "paragraph_rank": 117,
            "section_rank": 55
        },
        {
            "text": "virtual bool isCompactible(){ return true; } static unsigned int sizeOf(){ return FROG_Element_Base_With_DetId::sizeOf() + 6 * sizeof(float); }The class constructor is defined below:",
            "paragraph_rank": 118,
            "section_rank": 56
        },
        {
            "text": ") This class has itself been extended to a FROG Element Base With DetId And Name which contains a string in addition of the integer.",
            "paragraph_rank": 119,
            "section_rank": 56
        },
        {
            "text": "Acknowledgements",
            "section_rank": 58
        },
        {
            "section": "Acknowledgements",
            "text": "First of all we would like to thanks the many people that helped us in the writting of this paper, in particular Giacomo Bruno, Dorian Kcira and Xavier Rouby. Furthermore, we thanks the different collaboration that have contributed to this note : GASTOF , Delphes and the Caltech CMS Group.",
            "paragraph_rank": 120,
            "section_rank": 58
        },
        {
            "text": "First, the style is set by init(NULL). The right colour and thickness to used are transmitted to OPENGL for the line drawing, glLoadName is used to give an OPENGL name to the displayed line, this is need to allow mouse selection of the object (see sec. 5.6). Finally, the line is drawn by giving the two vertex positions between the markup glBegin(GL LINES) and glEnd().",
            "paragraph_rank": 121,
            "section_rank": 60,
            "ref_spans": [
                {
                    "type": "bibr",
                    "start": 253,
                    "text": "5.6)",
                    "end": 257
                }
            ]
        },
        {
            "text": "An extra method can be added to display some text when the object is mouse selected.",
            "paragraph_rank": 122,
            "section_rank": 60
        },
        {
            "text": "virtual void printInfos(char * buffer){ sprintf(buffer,\"LINE : Hit1 : x=%f y=%f z=%f\",P1X,P1Y,PIZ); sprintf(buffer,\"LINE : Hit2 : x=%f y=%f z=%f\",P2X,P2Y,P2Z); }",
            "paragraph_rank": 123,
            "section_rank": 60
        },
        {
            "text": "The function just fill a text buffer with the text to print on screen when the object is selected.",
            "paragraph_rank": 124,
            "section_rank": 60
        },
        {
            "text": "These are all the functions an advanced user needs to implement in order to add its own objects toolkit. More than 25 object classes can be found in FROG/FROG Element * .h that can be used as object class examples.",
            "paragraph_rank": 125,
            "section_rank": 60
        },
        {
            "text": "Geometry and Events Classes",
            "section_rank": 61
        },
        {
            "section": "Geometry and Events Classes",
            "text": "These two classes handle the FROG Elements tree, which is one of the private data members. The classes also contains specific functions useful to display only few parts of the geometry and/or the events. In order to keep the random-access memory used by the Displayer reduced, the event class loads the events one by one. When the next event has to be drawn, the current event is firstly unloaded and only then, the next one is loaded. This technique is not applicable for the geometry data because the event processing can request for a detector part information at any time. So it is more efficient to load the entire detector geometry at the beginning and to keep it in memory up to the end.",
            "paragraph_rank": 126,
            "section_rank": 61
        },
        {
            "section": "Geometry and Events Classes",
            "text": "These two classes will also take the FROG element tree writing in charge. The basic FROG user is not supposed to deal with the FROG Element Base. Those are just internal format used by the Geometry and Events classes to read, write and display objects. This fact will be shown in the next section.",
            "paragraph_rank": 127,
            "section_rank": 61
        },
        {
            "text": "Appendix B: Complete Example",
            "section_rank": 62
        },
        {
            "section": "Appendix B: Complete Example",
            "text": "This section shows an example of code used for a fictitious tracking experiment composed of a particle source beam, eleven tracking layers and a block to stop the beam. Others examples/tutorials are also available online as a tutorial [5].",
            "paragraph_rank": 128,
            "section_rank": 62,
            "ref_spans": [
                {
                    "type": "bibr",
                    "ref_id": "b3",
                    "start": 235,
                    "text": "[5]",
                    "end": 238
                }
            ]
        },
        {
            "text": "Producer Code",
            "section_rank": 63
        },
        {
            "section": "Producer Code",
            "text": "The Producer code is divided into four different methods: main, Build Geometry creates and stores the geometry of the detector, Build Events and Build 1Event simulate and store the events. The code includes the needed FROG classes, and defines the functions implemented in the file. Eventually, the main is implemented. The Build Geometry function creates the tree structure that is stored in the file. The root of the tree is necessary a FROG Element Base with a C PRIMARY chunk Id. The geometry branch is created and attached to this primary object. Other branches are created to reflect the detector structure, since they are of type FROG Element Base Width DetId And Name, those branches contain a unique detId that will be used to access the branch, and a string that give a name to the branch (e.g., \"TRACKER\" or \"OTHER\"). The eleven tracking layers are created in a loop and are represented by a rectangle attached to the \"TRACKER\" branch. The Build Events method creates the data tree that will contain all the new events. Hundred events are created and push in this tree. The events are of type FROG Element Event, the run and event numbers are given as an argument of the constructor. Once the new event has been filled by Build 1Event, and pushed in the data tree, they are stored on disk (one by one) by FROG Events::SaveInLive. The arguments of the function are used to set : the output file name, if the file has to be gzipped, if it has to be closed, and the maximum file size in bytes. The return value is FALSE when the new event will make the file size exceeding the maximum allowed file size (2 MB in this case). At the end, SaveInLive is call a last time to force the closing of the file. The method Build 1Event simulates and stores one event. The simulation consists a straight line propagation of the particle using a random emission angle from the particle source. During the propagation, a new hit is created and attached to the data tree, each time the particle is crossing a tracking layer. The data structure is such that the hits are contained in a track itself contained in a track collection. This simple example shows how a user can display his experimental setup using FROG in only few lines of code. The standard FROG package contains already more than 25 objects that can be used to render the detector geometry and events. Those classes have been shown in the Figure 13. In addition of those several available classes, the users can also create new classes to display particular objects that fit his needs, a tutorial is available online [5].",
            "paragraph_rank": 129,
            "section_rank": 63,
            "ref_spans": [
                {
                    "type": "figure",
                    "start": 2396,
                    "text": "Figure 13",
                    "end": 2405
                },
                {
                    "type": "bibr",
                    "ref_id": "b3",
                    "start": 2574,
                    "text": "[5]",
                    "end": 2577
                }
            ]
        },
        {
            "text": "Configuration Code",
            "section_rank": 64
        },
        {
            "section": "Configuration Code",
            "text": "The ASCII code below is the configuration file used to run FROG on the fictitious tracking experiment. ",
            "paragraph_rank": 130,
            "section_rank": 64
        }
    ]
}